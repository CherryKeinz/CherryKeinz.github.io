---
title: 常用设计模式-适配器、装饰者、代理
date: 2019-03-27 12:25:11
tags: [面试,设计模式]
categories: [面试,设计模式]

---


# 常用设计模式-适配器、装饰者、代理（java）

## 结构型

### 适配器模式

场景：结城明日奈想试试双刀流技能（<font color='red'>一个类的接口</font>）好不好玩，但是亚丝娜这个账号（<font color='red'>客户端所期待的接口</font>）没办法直接用双刀流（<font color='red'>接口不匹配的两个类无法一起工作</font>），只能借助适配器。

#### 类适配器
参考：[Java设计模式之《适配器模式》及应用场景](https://www.cnblogs.com/V1haoge/p/6479118.html)

原理：通过继承来实现适配器功能。

当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。

```java
// 亚丝娜账号
public interface IAsuna{
    void login();
}
// 双刀流
public interface IShuangDaoSkil{
    void releaseSkill();
}
// 双刀流实现类
public class ShuangDaoSkil implements IShuangDaoSkil{
    @Override 
    public void releaseSkill(){
        System.out.println("发动双刀流！");
    }
}
// 适配器
public class Adapter extends ShuangDaoSkil implements IAsuna{
    @Override 
    public void login(){
        releaseSkill();
    }
}

public class client{
    public static void main(String[] args) {
        IAsuna asuna = new Adapter();
        asuna.login();
    }
} 
```
#### 对象适配器模式
原理：通过组合来实现适配器功能。

当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。


```java
// 亚丝娜账号
public interface IAsuna{
    void login();
}
// 双刀流
public interface IShuangDaoSkil{
    void releaseSkill();
}
// 双刀流实现类
public class ShuangDaoSkil implements IShuangDaoSkil{
    @Override 
    public void releaseSkill(){
        System.out.println("发动双刀流！");
    }
}
// 适配器
public class Adapter implements IAsuna {
    private ShuangDaoSkil shuangDaoSkill;
    public Adapter(ShuangDaoSkil shuangDaoSkill){
        this.shuangDaoSkill = shuangDaoSkill;
    }
    @Override
    public void login(){
        shuangDaoSkill.releaseSkill();
    }
}
public class client{
    public static void main(String[] args) {
        IAsuna asuna = new Adapter(new ShuangDaoSkil());
        asuna.login();
    }
} 
```

#### 接口适配器模式

原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。

当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。

```java
// 目标接口
public interface ISkill{
    void skill1();
    void skill2();
    void skill3();
    void skill4();
    void skill5();
}
// 适配器
public abstract Adapter implements ISkill{
    public void skill1();
    public void skill2();
    public void skill3();
    public void skill4();
    public void skill5();
}
// 适配器实现类
public class Skill extends Adapter{
    public void skill1();
    public void skill2();
}
public class client{
    public static void main(String[] args) {
        Skill skill = new Skill;
        skill.skill1();
        skill.skill2();
    }
} 
```
#### 使用场景
##### 类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：
- 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。
- 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。

##### 接口适配器使用场景：

想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器。

### 装饰器

参考：[JAVA装饰器模式](https://www.cnblogs.com/qiumingcheng/p/5219631.html)、
[Java设计模式之装饰者模式](https://www.cnblogs.com/lzb1096101803/p/4425483.html)

Decorator装饰器，顾名思义，就是动态地给一个对象添加一些额外的职责，就好比为房子进行装修一样。因此，装饰器模式具有如下的特征：
- 它必须具有一个装饰的对象。
- 它必须拥有与被装饰对象相同的接口。
- 它可以给被装饰对象添加额外的功能。

用一句话总结就是：<font color='red'>保持接口，增强性能。</font>

实际上是基于对象的适配器模式的一种变种。它与对象的适配器模式的异同点如下:
- 相同点：都拥有一个目标对象。
- 不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。

要实现装饰者模式,注意一下几点内容:
1. 装饰者类要实现真实类<font color='red'>同样的接口</font>
2. 装饰者类内有一个<font color='red'>真实对象的引用</font>(可以通过装饰者类的构造器传入)
3. 装饰类对象在主类中接受请求,将<font color='red'>请求发送给真实的对象</font>(相当于已经将引用传递到了装饰类的真实对象)
4. 装饰者可以在传入真实对象后,<font color='red'>增加一些附加功能</font>(因为装饰对象和真实对象都有同样的方法,装饰对象可以添加一定操作在调用真实对象的方法,或者先调用真实对象的方法,再添加自己的方法)
5. 不用继承

来个实例 桐人砍怪：

```java
// 砍怪的接口
public interface IKirito{
    void takeSword();
    void releaseSkill();
    void getAward();
    void operation();
}
// 正常砍怪的实现类
public class Kirito implements IKirito{
    @Override
    public void takeSword(){
        System.out.println("取武器");
    }
    @Override
    public void releaseSkill(){
        System.out.println("放技能");
    }
    @Override
    public void getAward(){
        System.out.println("捡装备");
    }
    @Override
    public void operation() {
        takeSword();
        releaseSkill();
        getAward();
    }
}
// 定义出需要添加附加功能的抽象类
public abstract class AbstractKirito implements IKirito{
    private IKirito kirito;
    public AbstractKirito (IKirito kirito){
        super();
        this.kirito = kirito;
    }

    @Override
    public void takeSword(){
        this.kirito.takeSword();
    }
    @Override
    public void releaseSkill(){
        this.kirito.releaseSkill();
    }
    @Override
    public void getAward(){
        this.kirito.getAward();
    }
    @Override
    public void operation() {
        takeSword();
        releaseSkill();
        getAward();
    }
}
// 继承Abstarct类,所以可以有选择的覆盖正常生产馒头的方法,并添加原有方法原来的信息,同时也可以添加自己的方法    
//装饰者模式中这里最关键, 对应上述的第1个注意点:装饰者类要实现真实类同样的接口

public class WisdomDecorator extends AbstractKirito{
    public WisdomDecorator(IKirito kirito){
        super(kirito);
    }

    public void addWisdomBuff(){
        System.out.println("加智力buff");
    }

    @Override
    public void releaseSkill() {
        this.addWisdomBuff();
        super.releaseSkill();
    }
}

public class StrengthDecorator extends AbstractKirito{
    public StrengthDecorator(IKirito kirito){
        super(kirito);
    }

    public void addStrenthBuff(){
        System.out.println("加力量buff");
    }

    @Override
    public void releaseSkill() {
        this.addStrenthBuff();
        super.releaseSkill();
    }
}
public class AgilityDecorator extends AbstractKirito{
    public AgilityDecorator(IKirito kirito){
        super(kirito);
    }

    public void addAgilityBuff(){
        System.out.println("加敏捷buff");
    }

    @Override
    public void releaseSkill() {
        this.addAgilityBuff();
        super.releaseSkill();
    }
}

public class client{
    public static void main(String[] args) {
        IKirito kirito = new Kirito();
        kirito = new WisdomDecorator(kirito);
        kirito = new StrengthDecorator(kirito);
        kirito = new AgilityDecorator(kirito);
        kirito.operation();
    }
}
```
输出：
```
取武器
加敏捷buff
加力量buff
加智力buff
放技能
捡装备
```

装饰者模式中的4个角色
- 被装饰者抽象Component:是一个接口或者抽象类,定义最核心的对象,这个类是装饰者的基类,例如IKirito接口
- 被装饰者具体实现ConcreteComponent:这是Component接口或抽象类的实现,例如本例中的Kirito
- 装饰者Decorator:一般是抽象类,实现Component,它里面必然有一个指向Component的引用,例如本例中AbstractKirito
- 装饰者实现ConcreteDecorator1和ConcreteDecorator2:用来装饰最基本的类,如本例中的AgilityDecorator


### 代理模式
参考：[理解java的三种代理模式](https://www.cnblogs.com/boboxing/p/8126046.html)

代理模式是一种设计模式，简单说即是在不改变源码的情况下，实现对目标对象的功能扩展。

#### 静态代理


```java
public interface IPlayer{
    void play();
}

public class Player implements IPlayer{
    @Override
    public void play(){
        System.out.println("进行游戏");
    }
}

public class PlayerProxy implements IPlayer{
    private IPlayer player;
    
    public PlayerProxy(IPlayer player){
        this.player = player;
    }
    @Override
    public void play(){
        System.out.println("寻找伙伴");
        player.play();
    }
}

public class Test{
    public static void main(String[] args) {
        IPlayer player = new Player();
        PlayerProxy proxy = new PlayerProxy(player);
        proxy.play();
    }
}
```

**总结**：其实这里做的事情无非就是，创建一个代理类SingerProxy，继承了ISinger接口并实现了其中的方法。只不过这种实现特意包含了目标对象的方法，正是这种特征使得看起来像是“扩展”了目标对象的方法。假使代理对象中只是简单地对sing方法做了另一种实现而没有包含目标对象的方法，也就不能算作代理模式了。所以这里的包含是关键。

**缺点**：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出，如果接口层发生了变化，代理对象的代码也要进行维护。如果能在运行时动态地写出代理对象，不但减少了一大批代理类的代码，也少了不断维护的烦恼，不过运行时的效率必定受到影响。这种方式就是接下来的动态代理。

#### 动态代理（JDK代理）
跟静态代理的前提一样，依然是对Singer对象进行扩展

```java
public interface IPlayer{
    void play();
}

public class Player implements IPlayer{
    @Override
    public void play(){
        System.out.println("进行游戏");
    }
}
```

调用Proxy类的静态方法newProxyInstance即可，该方法会返回代理类对象

```java
public class Test{
    public static void main(String[] args) {
        // 1. 创建实例
        Player target = new Player();
        IPlayer proxy  = (IPlayer) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // 2. 扩展1
                        System.out.println("寻找伙伴");
                        //执行目标对象方法
                        Object returnValue = method.invoke(target, args);
                        // 3. 扩展2
                        System.out.println("很开心");
                        return returnValue;
                    }
                });
        // 4. 目标对象的方法
        proxy.play();
    }
}
```
**总结**：以上代码只有1234部分是需要自己写出，其余部分全都是固定代码。由于java封装了newProxyInstance这个方法的实现细节，所以使用起来才能这么方便。
**缺点**：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，假如没有，则可以使用Cglib代理。

#### Cglib代理
前提条件：

- 需要引入cglib的jar文件，由于Spring的核心包中已经包括了Cglib功能，所以也可以直接引入spring-core-3.2.5.jar
- 目标类不能为final
- 目标对象的方法如果为final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法

```java
public class Player {
    public void play(){
        System.out.println("进行游戏");
    }
}
```


```java
/**
 * Cglib子类代理工厂
 */
public class ProxyFactory implements MethodInterceptor{
    // 维护目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    // 给目标对象创建一个代理对象
    public Object getProxyInstance(){
        //1.工具类
        Enhancer en = new Enhancer();
        //2.设置父类
        en.setSuperclass(target.getClass());
        //3.设置回调函数
        en.setCallback(this);
        //4.创建子类(代理对象)
        return en.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 步骤1
        System.out.println("向观众问好");
        //执行目标对象的方法
        Object returnValue = method.invoke(target, args);
        // 步骤2
        System.out.println("谢谢大家");
        return returnValue;
    }
}


/**
 * 测试类
 */
public class Test{
    public static void main(String[] args){
        //目标对象
        Player target = new Player();
        //代理对象
        Player proxy = (Player)new ProxyFactory(target).getProxyInstance();
        //执行代理对象的方法
        proxy.play();
    }
}
```

这里的代码也非常固定，只有步骤1、2是需要自己写出.

**总结**：三种代理模式各有优缺点和相应的适用范围，主要看目标对象是否实现了接口。

以Spring框架所选择的代理模式举例：在Spring的AOP编程中：
- 如果加入容器的目标对象有实现接口，用JDK代理
- 如果目标对象没有实现接口，用Cglib代理

