---
title: 常用设计模式-工厂模式和单例
date: 2019-03-26 16:51:26
tags: [面试,设计模式]
categories: [面试,设计模式]

---

# 常用设计模式-工厂模式和单例（java）

## 创建型

### 三种工厂模式

#### 简单工厂模式
参考：
[java 三种工厂模式](https://note.youdao.com/)

简单工厂模式又 叫静态工厂方法模式（Static FactoryMethod Pattern），是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

##### 代码示例：
一个抽象的武器接口：

```java
public interface ISword{
    void swordSkill();
}
```

一个具体产品类，武器阐释者：

```java
public class ChanShiZhe implements ISword{
    @Override
    public void swordSkill(){
        System.out.println("阐释者——星爆弃疗斩");
    }
}
```

另一个具体产品类，武器闪烁之光：
```java
public class ShanShuoZhiGuang implements ISword{
    @Override
    public void swordSkill(){
        System.out.println("闪烁之光——圣母圣咏");
    }
}
```

简单工厂类：
```java
public class SimplySwordFactory{
    public static final int TYPE_CSZ = 1;
    public static final int TYPE_SSZG = 2;
    
    public static ISword createSword(int type){
        switch(type){
            case TYPE_CSZ: 
                return new ChanShiZhe();
            case TYPE_SSZG:
                return new ShanShuoZhiGuang();
            default:
                return new ChanShiZhe();
        }
    }
}
```

测试：
```java
public class SimpleFactoryTest {
    public static void main(String[] args){
        ISword sword = SimplySwordFactory.createSword(SimplySwordFactory.TYPE_CSZ);
        sword.swordSkill();
    }
}
```
##### 总结
特点：
- 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。
- create()方法通常是静态的，所以也称之为静态工厂。
缺点：
- 扩展性差（我想增加一种武器，除了新增一个武器产品类，还需要修改工厂类方法）
- 不同的产品需要不同额外参数的时候 不支持。

#### 工厂方法

提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。

步骤：
1. 创建抽象工厂类，定义具体工厂的公共接口；
2. 创建抽象产品类 ，定义具体产品的公共接口；
3. 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
4. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
5. 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

##### 代码示例：
工厂接口：
```java
public interface Factory {
    ISword createSword();
}
```
其实现类（获取具体产品）:
```java
public class ChanShiZheFactory implements Factory{
    @Override
    public ISword createSword(){
        return new ChanShiZhe();
    }
}
```

```java
public class ShanShuoZhiGuangFactory implements Factory{
    @Override
    public ISword createSword(){
        return new ShanShuoZhiGuang();
    }
}
```
测试：
```java
public class FactoryTest {
    public static void main(String[] args){
        ISword csz = new ChanShiZheFactory().createSword();
        csz.swordSkill();
        ISword sszg = new ShanShuoZhiGuangFactory().createSword();
        sszg.swordSkill();
    }
}
```

##### 总结
优点：
- 更符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可
- 符合单一职责原则：每个具体工厂类只负责创建对应的产品
- 不使用静态工厂方法，可以形成基于继承的等级结构

缺点：
- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类
- 一个具体工厂只能创建一种具体产品


#### 抽象工厂模式
参考：
[Java设计模式之抽象工厂模式](https://note.youdao.com/)

当每个抽象产品都有多于一个的具体子类的时候（空调有型号A和B两种，发动机也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品（产品空调有两个具体产品空调A和空调B）。抽象工厂模式提供两个具体工厂角色（宝马320系列工厂和宝马230系列工厂），分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。

##### 代码示例：
产品类：

```java
// 武器及型号
public interface Sword {  
    
} 

public class SwordA extends Sword{  
    public EngineA(){  
        System.out.println("装备-->SwordA");  
    }  
}  
public class SwordB extends Sword{  
    public EngineB(){  
        System.out.println("装备-->SwordB");  
    }  
}  

//技能及型号
public interface Skill {  

}  
public class SkillA extends Skill{  
    public SkillA(){  
        System.out.println("装备-->SkillA");  
    }  
}  
public class SkillB extends Skill{  
    public SkillB(){  
        System.out.println("装备-->SkillB");  
    }  
} 
```
创建工厂类

```java
//创建工厂的接口  
public interface AbstractFactory {  
    //装备武器
    public Sword createSword();
    //装备技能 
    public Skill createSkill(); 
}  


//为桐人装备  
public class Factorykirito implements AbstractFactory{  
      
    @Override  
    public Sword createSword() {    
        return new SwordA();  
    }  
    @Override  
    public Skill createSkill() {  
        return new SkillA();  
    }  
}  
//为亚丝娜装备 
public class FactoryAsuna implements AbstractFactory {  
  
     @Override  
    public Sword createSword() {    
        return new SwordB();  
    }  
    @Override  
    public Skill createSkill() {  
        return new SkillB();  
    }  
} 
```

测试类
```java
public class FactoryTest  {  
    public static void main(String[] args){  
        //生产桐人
        Factorykirito factorykirito = new Factorykirito();  
        factorykirito.createSword();
        factorykirito.createSkill();
          
        //生产亚丝娜
        FactoryAsuna factoryAsuna = new FactoryAsuna();  
        factoryAsuna.createSword();
        factoryAsuna.createSkill();
    }  
}
```

### 七种单例模式
参考： 
[Java 单例模式](https://note.youdao.com/)

为什么使用单例：
- 在内存中只有一个对象，节省内存空间。避免频繁的创建销毁对象，可以提高性能。避免对共享资源的多重占用。可以全局访问。
- 确保一个类只有一个实例，自行实例化并向系统提供这个实例。

单例需要注意的问题：
- 线程安全问题
- 资源使用问题

#### 饿汉式

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    
    private Singleton(){
        
    }
    
    public static Singleton getInstance(){
        return instance;
    }
}
```
- 优点：未调用getInstance()时，实例已经创建，天生线程安全。
- 缺点：如果一直没有调用getInstance()，但是实例已经存在，资源浪费。

#### 懒汉式

```java
public class Singleton{
    private static Singleton instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return intance;
    }
}
```
- 优点：方法被调用时才创建实例，节省资源。
- 缺点：线程不安全。


<font color='red'>只有单线程才是单例，多线程可能出现多个单例。</font>

#### synchronized加锁同步

```java
public class Singleton(){
    private static Singleton instance;
    
    private Singleton(){}
    
    public synchronized static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
```
- 优点：同时满足单线程、多线程。
- 缺点：性能差。

#### 双重校验

```java
public class Singleton(){
    private static Singleton instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

- 优点：同时满足单线程、多线程；性能问题得到优化。
- 缺点：第一次加载慢，由于java内存模型一些原因偶尔失败。

#### volatile关键字


```java
public class Singleton{
    private static volatile instance;
    
    private Singleton(){}
    
    public static Singleton getInstance(){
        if(instance = null){
            synchronized(Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
<font color='red'>volatile关键字可以解决指令重排。</font>如果没有volatile，两个线程AB，都是第一次调用方法，线程A先执行new，该构造方法是非原子性操作，编译后产生多条字节码指令，由于指令重排，可能会先执行赋值操作，即在内存中开辟空间，然后返回内存的引用，之后instance不再为空，但是实际初始化并未完成，此时线程B进入就会看到不为空但是不完整（初始化未完成）的Singleton对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。

#### 静态内部类

静态内部类由JVM来保证线程安全。

```java
public class Singleton{
    private Singleton(){}
    
    private static class SingletonHolder{
        private static Singleton instance = new Singleton();
    }
    
    public static Singleton getInstance(){
        return SingletonsHolder.instance;
    }
}
```
- 优点：资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法。

#### 枚举类实现单例

```
使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。
——Joshua Bloch《effective java》
```
<font color='red'>枚举天生线程安全，且可避免反序列化破坏单例。</font>

more detail：[为什么我强烈建议大家使用枚举来实现单例](https://note.youdao.com/)
```java
public enum Singleton{
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```
