<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用设计模式-工厂模式和单例]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[常用设计模式-工厂模式和单例（java）创建型三种工厂模式简单工厂模式参考：java 三种工厂模式 简单工厂模式又 叫静态工厂方法模式（Static FactoryMethod Pattern），是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 代码示例：一个抽象的武器接口： 123public interface ISword&#123; void swordSkill();&#125; 一个具体产品类，武器阐释者： 123456public class ChanShiZhe implements ISword&#123; @Override public void swordSkill()&#123; System.out.println("阐释者——星爆弃疗斩"); &#125;&#125; 另一个具体产品类，武器闪烁之光：123456public class ShanShuoZhiGuang implements ISword&#123; @Override public void swordSkill()&#123; System.out.println("闪烁之光——圣母圣咏"); &#125;&#125; 简单工厂类：123456789101112131415public class SimplySwordFactory&#123; public static final int TYPE_CSZ = 1; public static final int TYPE_SSZG = 2; public static ISword createSword(int type)&#123; switch(type)&#123; case TYPE_CSZ: return new ChanShiZhe(); case TYPE_SSZG: return new ShanShuoZhiGuang(); default: return new ChanShiZhe(); &#125; &#125;&#125; 测试：123456public class SimpleFactoryTest &#123; public static void main(String[] args)&#123; ISword sword = SimplySwordFactory.createSword(SimplySwordFactory.TYPE_CSZ); sword.swordSkill(); &#125;&#125; 总结特点： 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。 create()方法通常是静态的，所以也称之为静态工厂。缺点： 扩展性差（我想增加一种武器，除了新增一个武器产品类，还需要修改工厂类方法） 不同的产品需要不同额外参数的时候 不支持。 工厂方法提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。 步骤： 创建抽象工厂类，定义具体工厂的公共接口； 创建抽象产品类 ，定义具体产品的公共接口； 创建具体产品类（继承抽象产品类） &amp; 定义生产的具体产品； 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法； 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例 代码示例：工厂接口：123public interface Factory &#123; ISword createSword();&#125; 其实现类（获取具体产品）:123456public class ChanShiZheFactory implements Factory&#123; @Override public ISword createSword()&#123; return new ChanShiZhe(); &#125;&#125; 123456public class ShanShuoZhiGuangFactory implements Factory&#123; @Override public ISword createSword()&#123; return new ShanShuoZhiGuang(); &#125;&#125; 测试：12345678public class FactoryTest &#123; public static void main(String[] args)&#123; ISword csz = new ChanShiZheFactory().createSword(); csz.swordSkill(); ISword sszg = new ShanShuoZhiGuangFactory().createSword(); sszg.swordSkill(); &#125;&#125; 总结优点： 更符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可 符合单一职责原则：每个具体工厂类只负责创建对应的产品 不使用静态工厂方法，可以形成基于继承的等级结构 缺点： 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类 一个具体工厂只能创建一种具体产品 抽象工厂模式参考：Java设计模式之抽象工厂模式 当每个抽象产品都有多于一个的具体子类的时候（空调有型号A和B两种，发动机也有型号A和B两种），工厂角色怎么知道实例化哪一个子类呢？比如每个抽象产品角色都有两个具体产品（产品空调有两个具体产品空调A和空调B）。抽象工厂模式提供两个具体工厂角色（宝马320系列工厂和宝马230系列工厂），分别对应于这两个具体产品角色，每一个具体工厂角色只负责某一个产品角色的实例化。每一个具体工厂类只负责创建抽象产品的某一个具体子类的实例。 代码示例：产品类： 123456789101112131415161718192021222324252627282930// 武器及型号public interface Sword &#123; &#125; public class SwordA extends Sword&#123; public EngineA()&#123; System.out.println("装备--&gt;SwordA"); &#125; &#125; public class SwordB extends Sword&#123; public EngineB()&#123; System.out.println("装备--&gt;SwordB"); &#125; &#125; //技能及型号public interface Skill &#123; &#125; public class SkillA extends Skill&#123; public SkillA()&#123; System.out.println("装备--&gt;SkillA"); &#125; &#125; public class SkillB extends Skill&#123; public SkillB()&#123; System.out.println("装备--&gt;SkillB"); &#125; &#125; 创建工厂类 123456789101112131415161718192021222324252627282930313233//创建工厂的接口 public interface AbstractFactory &#123; //装备武器 public Sword createSword(); //装备技能 public Skill createSkill(); &#125; //为桐人装备 public class Factorykirito implements AbstractFactory&#123; @Override public Sword createSword() &#123; return new SwordA(); &#125; @Override public Skill createSkill() &#123; return new SkillA(); &#125; &#125; //为亚丝娜装备 public class FactoryAsuna implements AbstractFactory &#123; @Override public Sword createSword() &#123; return new SwordB(); &#125; @Override public Skill createSkill() &#123; return new SkillB(); &#125; &#125; 测试类12345678910111213public class FactoryTest &#123; public static void main(String[] args)&#123; //生产桐人 Factorykirito factorykirito = new Factorykirito(); factorykirito.createSword(); factorykirito.createSkill(); //生产亚丝娜 FactoryAsuna factoryAsuna = new FactoryAsuna(); factoryAsuna.createSword(); factoryAsuna.createSkill(); &#125; &#125; 七种单例模式参考：Java 单例模式 为什么使用单例： 在内存中只有一个对象，节省内存空间。避免频繁的创建销毁对象，可以提高性能。避免对共享资源的多重占用。可以全局访问。 确保一个类只有一个实例，自行实例化并向系统提供这个实例。 单例需要注意的问题： 线程安全问题 资源使用问题 饿汉式1234567891011public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 优点：未调用getInstance()时，实例已经创建，天生线程安全。 缺点：如果一直没有调用getInstance()，但是实例已经存在，资源浪费。 懒汉式123456789101112public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return intance; &#125;&#125; 优点：方法被调用时才创建实例，节省资源。 缺点：线程不安全。 只有单线程才是单例，多线程可能出现多个单例。 synchronized加锁同步123456789101112public class Singleton()&#123; private static Singleton instance; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优点：同时满足单线程、多线程。 缺点：性能差。 双重校验12345678910111213141516public class Singleton()&#123; private static Singleton instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优点：同时满足单线程、多线程；性能问题得到优化。 缺点：第一次加载慢，由于java内存模型一些原因偶尔失败。 volatile关键字12345678910111213141516public class Singleton&#123; private static volatile instance; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance = null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; volatile关键字可以解决指令重排。如果没有volatile，两个线程AB，都是第一次调用方法，线程A先执行new，该构造方法是非原子性操作，编译后产生多条字节码指令，由于指令重排，可能会先执行赋值操作，即在内存中开辟空间，然后返回内存的引用，之后instance不再为空，但是实际初始化并未完成，此时线程B进入就会看到不为空但是不完整（初始化未完成）的Singleton对象，所以需要加入volatile关键字，禁止指令重排序优化，从而安全的实现单例。#### 静态内部类静态内部类由JVM来保证线程安全。1234567891011public class Singleton&#123; private Singleton()&#123;&#125; private static class SingletonHolder&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonsHolder.instance; &#125;&#125;- 优点：资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法。#### 枚举类实现单例12使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。——Joshua Bloch《effective java》枚举天生线程安全，且可避免反序列化破坏单例。 more detail：为什么我强烈建议大家使用枚举来实现单例12345public enum Singleton&#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125;]]></content>
      <categories>
        <category>面试</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识总结]]></title>
    <url>%2F2019%2F03%2F26%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[操作系统面试知识总结摘自：https://blog.csdn.net/justloveyou_/article/details/78304294 进程和线程区别 进程是具有一定功能的程序关于某个数据集合的一次运行活动，进程是系统进行资源调度和分配的一个独立单位。 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 一个进程可以有多个线程，多个线程可以并发运行。 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 more detail：进程与线程的一个简单解释： 线程同步的方式 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才能访问公共资源。因为互斥对象只有一个，所以能保证一个时刻只有一个线程访问公共资源。 信号量：它允许同一时刻多个线程访问公共资源，但是要控制同一时刻访问的最大线程数量。 事件（信号）：通过通知操作保持多线程同步，还能实现多线程优先级比较。 进程间的通信的几种方式 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列：是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等； 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段； 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。 什么是死锁？死锁产生的条件在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。 死锁产生的四个必要条件 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止； 占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有； 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系 死锁的处理基本策略和常用方法解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等。 死锁预防只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生 打破互斥条件：由资源本身属性决定，无实际意义。 打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。 打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。 死锁避免死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。 死锁解除死锁解除的常用两种方法为进程终止和资源抢占。 进程有哪几种状态 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源； 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数； 阻塞状态：进程等待某种条件，在条件满足之前无法执行； 线程有哪几种状态在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态。 分页和分段有什么区别（内存管理）段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片） 页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。 区别 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息； 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定； 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间； 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制； 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。 操作系统中进程调度策略有哪几种 FCFS(先来先服务，队列实现，非抢占的)：先请求CPU的进程先分配到CPU SJF(最短作业优先调度算法)：平均等待时间最短，但难以知道下一个CPU区间长度 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化 时间片轮转调度算法(可抢占的)：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识总结]]></title>
    <url>%2F2019%2F03%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[计算机网络面试知识总结OSI、TCP/IP、五层协议的体系结构 OSI七层结构 物理层：通过媒介传输比特，确定机械及电气规范（Bit） 数据链路层：将比特组装成帧和点到点的传输（帧Frame） 网络层：负责数据包从源到宿的传输和网际互联（数据包Packet） 传输层：提供端对端的可靠报文传输和错误恢复（段Segment） 会话层：建立、管理、终止会话。（会话协议数据单元SPDU） 表示层：对数据翻译，加密，压缩。（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段。（应用协议数据单元APDU） TCP/IP四层结构 数据链路层（网络接口层/从主机到网络层）：模型没有真正描述这一层实现，只是为上一层提供接口。 网络层：处理和分组相关，协议主要包括：IP协议（网际协议）、ICMP协议（Internet网络控制报文协议）、IGMP协议（Internet组管理协议）。 传输层：为两台主机应用提供端对端的通信。TCP、UDP。 应用层：负责处理特殊应用程序细节。Telnet、FTP、SMTP、SNMP（简单网络管理协议） IP层提供不可靠的服务。TCP提供可靠的服务。为了提供可靠服务，TCP采用超时重传、发送和接收端到端的确认分组机制。 常用端口和对应服务 端口 服务 21 FTP 22 SSH 23 TELNET 25 SMTP 53 DNS 80 HTTP 110 POP3 443 HTTPS 1080 SOCKETS 3306 MYSQL TCP三次握手 四次挥手三次握手： 1234sequenceDiagramClient-&gt;&gt;Server: SYN seq = xServer-&gt;&gt;Client: SYN seq = y, ACK = x+1Client-&gt;&gt;Server: ACK = y+1 第一次握手：建立连接，客户端发送连接请求报文段，将SYN位置为1，sequence number为x，然后进入SYN_SEND状态，等待服务端。 第二次握手：服务器接收到请求，对SYN报文段进行确认，设置acknowledge number设置为x+1，将SYN置为1，sequence number为y，将所有信息放入一个报文段中，发送给客户端，进入SYN_RECV状态。 第三次握手：客户端接收到报文段，将acknowledge number置为y+1，向服务端发送ACK报文段，发送完毕后，进入ESTABLISHED状态。 四次挥手：12345sequenceDiagramClient-&gt;&gt;Server: FIN seq = x+2, ACK = y+1Server-&gt;&gt;Client: ACK = x+3Server-&gt;&gt;Client: FIN seq = y+1Client-&gt;&gt;Server: ACK = y+2 第一次挥手：客户端发送FIN请求关闭。第二次挥手：服务端接收到FIN，回复ACK，序号为收到的+1。第三次挥手：服务端发送一个FIN，关闭服务端到客户端的传输。第四次挥手：客户端收到FIN，回复ACK，序号为收到的+1。 IP地址 类别 网络号 地址范围 网络号 主机号 私有地址 A类 以0开头 1.0.0.0 – 127.255.255.255 8位 24位 10.0.0.0 - 10.255.255.255 B类 以10开头 128.0.0.0 – 191.255.255.255 16位 16位 172.16.0.0 - 172.31.255.255 C类 以110开头 192.0.0.0 – 223.255.255.255 24位 8位 192.168.0.0 - 192.168.255.255 TCP/UDP区别TCP 优点：可靠，稳定。需要三次握手才能建立接连。传输时有重传、确认、窗口、拥塞控制。 缺点：慢，效率低。各种机制消耗时间、占用资源。 UDP： 优点：快，比TCP稍安全。 缺点：不可靠，不稳定。网络不好会丢包。 区别 区别 TCP UDP 连接 面向连接 面向无连接 可靠性 可靠，无丢失，无差错，不重复 不保证可靠性交付 模式 流模式（字节流） 数据报模式（报文） 连接 点到点 支持一对一，一对多，多对一，多对多 首部开销 20字节 8字节 逻辑通信信道 全双工的可靠信道 不可靠信道 速度 慢 快 对系统资源要求 较多 较少 ARP协议 首先，每个主机会在自己的ARP缓冲区建立一个ARP列表，保存IP和MAC的对应关系。 当源主机要发送数据时，现在自己的ARP列表是否要对应的IP地址，如果有，直接发送，如果没有，会在网段内所有主机发送数据包，包括：源主机IP，源主机MAC地址，目的主机IP。 当本网段所有主机接收到数据包时，先检查数据包中的目的主机是否是自己的IP，如果不是，忽略；如果是，更新自己ARP，将源主机IP和MAC写入，并将自己的MAC地址写入响应包。 源主机接收到相应包，将目的主机MAC和IP写入ARP列表，然后以此通信。如果一直没有响应包，则ARP查询失败。 从输入网址到获得页面的过程 DNS查询，查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器。 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 Session 与 Cookie 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全； 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。 Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。 Http和Https的区别Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 开销：Https通信需要证书，而证书一般需要向认证机构购买； Get与POST的区别 功能：GET用于获取资源，POST修改资源。 REST服务：GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变； 请求参数形式：GET放在HTTP报文请求头中，POST放在请求体中。 安全性：POST安全性高。 请求大小：GET的URL长度有限，POST没有大小限制。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法-java实现]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[常用排序算法-java实现快排 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(n²) O(1)（原地分区递归版） 1234567891011121314151617181920212223public void quickSort(int[] array)&#123; return sort(array, 0, array.length);&#125;private int getMid(int[] array, int start, int end)&#123; int temp = array[start]; while(start &lt; end)&#123; while(start &lt; end &amp;&amp; temp &lt; array[end]) end--; array[end] = array[start]; while(start &lt; end &amp;&amp; temp &gt; array[start]) start++; array[start] = array[high]; &#125; array[start] = temp; return start;&#125;private void sort(int[] array, int start, int end)&#123; if(start &lt; end)&#123; int mid = getMid(array, start, end); sort(array, start, mid - 1); sort(array, mid + 1, end); &#125;&#125; 堆排序 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n)） 12345678910111213141516171819202122232425public void mergeSort(int[] array)&#123; return merge(array, 0, array.length - 1);&#125;private void merge(int[] array, int start, int end)&#123; if(end == start) return; int mid = (end + start) / 2; int i = start, j = mid + 1, index = 0; int[] copy = new int[end - start + 1]; merge(array, start, mid); merge(array, mid + 1, end); while(i &lt;= mid &amp;&amp; j &lt;= end)&#123; if(array[i] &gt; array[j]) copy[index++] = array[j++]; else copy[index++] = array[i++]; &#125; while(i &lt;= mid) copy[index++] = array[i++]; while(j &lt;= end) copy[index++] = array[j++]; for(int m = 0; m &gt; copy.length; m++) array[start + m] = copy[m];&#125; 堆排序 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(1)） 123456789101112131415161718192021public void heapSort(int[] array)&#123; for(int i = array.length - 1; i &gt; 0; i--)&#123; maxHeapify(array, i); int temp = array[i]; array[i] = array[0]; array[0] = temp; &#125;&#125;private void maxHeapify(int[] array, int index)&#123; int child; for(int i = (index - 1)/ 2; i &gt; 0; i--)&#123; child = 2 * i + 1; if(array[child + 1] &gt; array[child]) child++; if(array[child] &gt; array[i])&#123; int temp = array[child]; array[child] = array[i]; array[i] = temp; &#125; &#125;&#125; 基数 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(d*(n+r)) O(d*(n+r)) O(d*(n+r)) O(n+r) 12345678910111213141516171819202122public void radixSort(int[] array, int d)&#123; int[][] bucket = new int[10][array.length]; int n = 1; int index = 0; while(n &lt; d)&#123; int[] order = new int[10]; for(int num : array)&#123; int digit = num / n % 10; bucket[digit][order[digit]] = num; order[digit]++; &#125; for(int i = 0; i &lt; bucket.length; i++)&#123; if(order[i] == 0) continue; for(int j = 0; j &lt; order[i]; j++)&#123; array[index++] = bucket[i][j]; &#125; &#125; index = 0; n *= 1; &#125;&#125; 希尔 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(nlog2 n) O(nlog2 n) O(nlog2 n) O(1) 12345678910111213141516public void shellSort(int[] array)&#123; int length = array.length; int d = length / 2; while(d &gt; 0)&#123; for(int i = 0; i &lt; length; i++)&#123; for(int j = i; j + d &lt; length; j += d)&#123; if(array[j] &lt; array[i])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125; d /= 2; &#125;&#125; 冒泡 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n) O(n²) O(1) 1234567891011public void bubbleSort(int[] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; for(int j = 0; j &lt; array.length - 1 - i; j++)&#123; if(array[j] &lt; array[j + 1])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125;&#125; 选择 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) 123456789101112131415public void selectSort(int[] array)&#123; for(int i = 0; i &lt; array.length; i++)&#123; int min = i; for(int j = i + 1; j &lt; array.length; j++)&#123; if(array[j] &lt; array[j + 1])&#123; min = j; &#125; &#125; if(min != i)&#123; int temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125;&#125; 直接插入 平均时间复杂度 最好情况 最坏情况 空间复杂度 O(n²) O(n²) O(n²) O(1) 123456789101112public void insertSort(int[] array)&#123; if(array.length &lt; 1) return; for(int i = 1; i &lt; array.length; i++)&#123; int num = array[i]; int j; for(j = i; j &gt; 0 &amp;&amp; array[j] &gt; num; j--)&#123; array[j] = array[j - 1]; &#125; array[i] = num; &#125;&#125; 总结、对比 算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n²) O(1) 稳定 选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 直接插入排序 O(n²) O(n) O(n²) O(1) 稳定 折半插入排序 O(n²) O(n) O(n²) O(1) 稳定 希尔排序 O(n^1.3) O(nlogn) O(n²) O(1) 不稳定 归并排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(n) 稳定 快速排序 O(nlog₂n) O(nlog₂n) O(n²) O(nlog₂n) 不稳定 堆排序 O(nlog₂n) O(nlog₂n) O(nlog₂n) O(1) 不稳定 基数排序 O(n+k) O(n+k) O(n+k) O(k) 稳定 桶排序 O(n+k) O(n+k) O(n²) O(n+k) (不)稳定 基数排序 O(d(n+k)) O(d(n+k)) O(d(n+kd)) O(n+kd) 稳定 参考文献：https://www.cnblogs.com/morethink/p/8419151.html#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo换机前后的需要做的]]></title>
    <url>%2F2019%2F03%2F24%2Fhexo%E6%8D%A2%E7%94%B5%E8%84%91%E8%A6%81%E5%81%9A%E7%9A%84%2F</url>
    <content type="text"><![CDATA[换机之前的步骤 克隆项目到本地 1git clone 项目 进入项目文件夹，删掉除.git外的所有。 把原来hexo内所有内容复制过来。 创建分支 1git checkout -b hexo 添加add、commit、推送，操作类似普通项目 123git add --allgit commit -m &quot;&quot;git push --set-upstream origin hexo 发布博客和更新 12hexo new post &quot;新文章&quot;hexo d -g git三部曲 123git add . git commit -m &quot;注释&quot; git push origin hexo 换机之后的步骤 clone到本地 1git clone -b hexo 项目 发布博客和更新 12hexo new post &quot;新文章&quot;hexo d -g git三部曲 123git add . git commit -m &quot;注释&quot; git push origin hexo 参考文献： https://blog.csdn.net/heimu24/article/details/81210640]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库其他知识]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库其他知识 其他知识delete truncate drop区别 区别 delete truncate drop 类型回滚 可回滚 不可回滚 不可回滚 删除内容 表结构还在，删除表全部或部分内容 表结构还在，删除全部内容 删除表，所有数据、索引、权限一并删除 删除速度 逐行删除，速度慢 速度快 速度快 存储过程预编译的sql语句，一次创建，多次使用。 优点 预编译，效率高。 存放在数据库，减少网络传输。 安全性高，需要一定权限。 一次创建可多次使用，提高开发效率。 视图从一个表或多个表导出的表，是虚表，不存具体数据。 主从复制将主数据库的DDL、DML操作记录到二进制文件（BINLOG），传输到从数据库，从数据库重新执行，使得从数据库数据和主数据库保持一致。 主从复制作用 主数据库故障可以切换到从数据库； 可以读写分离； 从数据库可以日志备份。 复制过程 主数据库更新数据完成前，将操作记录顺序记录到BINLOG； 从数据库开启一个I/O线程，该线程在主数据库打开一个普通连接，将读到的事件写入到中继日志，如果读取的进度跟上了master，就进入睡眠等待； 从数据库的SQL线程将读取中继日志，并顺序执行操作。 大表数据查询的优化 优化Schema，sql语句、索引。 加缓存，memcached，redis 主从复制，读写分离 垂直拆分，分布式系统 水平切分，要选择合适的sharding key，为了好的查询效率，表结构也要改变，应用也需要改变，sql中尽量带sharding key，将数据定位到限定的表去查，而不是全部的表。 参考文献：https://www.weiweiblog.cn/databases/]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务总结]]></title>
    <url>%2F2019%2F03%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[数据库事务总结 事务事务是一个不可分割的数据库操作序列，是数据库并发操作的基本单位，其结果是从一种一致性状态到另一种一致性状态。 四大特性（ACID）原子性（Atomicity）事务是数据库逻辑工作单位，其操作要么全做，要么全不做。 一致性（Consistency）其结果必须是从一种一致性状态到另一种一致性状态。 隔离性（Isolation）一个事务的执行不能被其他事务干扰。 持久性（Duration）持久性表示一旦事务被提交了，数据库的数据改变就是永久性的，即使遇到故障也不会丢失提交的操作。 不考虑隔离性会出现的问题 脏读： 一个事务读到了另一个未提交事务的数据。 不可重复读：一个事务两次查询的间隔中，另一个事务修改并提交了数据，导致两次查询结果不同。 幻读：一个事务两次查询中数据笔数不一致。 不可重复读和幻读都是查询中被另一个事务修改并提交了，不同的是不可重复读查询的是同一条数据，幻读是一批数据（比如数据的条数）。 隔离级别 Read Uncommitted(读未提交)：所有事务都可以看到其他事务未提交的结果。一般很少用。 Read commited(读已提交)：一个事务只能看见已提交的结果。除mysql外大多数数据库默认。 Repeatable Read(可重复读)：确保了同一个事务的多个实例并发读数据时能看到相同的结果。mysql默认。 Serializable(顺序读)：最高的隔离级别，解决了幻读，但会出现大量超时和锁竞争。 事务隔离级别对比 事务隔离级别 脏读 不可重复读 幻读 Read Uncommitted 允许 允许 允许 Read commited 不允许 允许 允许 Repeatable Read 不允许 不允许 允许 Serializable 不允许 不允许 不允许 隔离级别与锁Read Uncommitted：读操作不加S锁。Read commited：读操作加S锁，在语句执行完释放锁。Repeatable Read：读操作加S锁，事务提交后释放锁。Serializable：在Repeatable read的基础上，加范围锁。 操作start transaction;开始事务 commit; 提交 rollback; 回滚 参考文献：https://www.weiweiblog.cn/databases/]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题 27——36]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%2027-36%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 27——36剑指offer算法题 2727 二叉搜索树转换成双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 “不能创建任何新的结点”，但是需要new tail new tail 递归或栈的方法中序遍历。 1234567891011121314151617181920212223242526272829303132333435363738/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; TreeNode head = null; TreeNode tail = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree == null) return null; ConvertNode(pRootOfTree); return head; &#125; private void ConvertNode(TreeNode node)&#123; if(node == null) return; ConvertNode(node.left); if(head == null)&#123; head = node; tail = node; &#125;else&#123; tail.right = node; node.left = tail; tail = node; &#125; ConvertNode(node.right); &#125;&#125; 28 字符串排列输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 按字典序打印，需要把结果：Collections.sort(res); 避免重复的，需要判断：if(i != index &amp;&amp; chars[i] == chars[index]) 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;public class Solution &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; char[] chars = str.toCharArray(); if(str.length() == 0) return res; res = Permutation(chars, 0); Collections.sort(res); return res; &#125; private ArrayList&lt;String&gt; Permutation(char[] chars, int index)&#123; if(index == chars.length - 1) res.add(String.valueOf(chars)); else&#123; for(int i = index; i &lt; chars.length; i++)&#123; if(i != index &amp;&amp; chars[i] == chars[index])&#123; continue; &#125; swap(chars, i, index); Permutation(chars, index + 1); swap(chars, index, i); &#125; &#125; return res; &#125; private void swap(char[] chars, int i ,int j)&#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125;&#125; 29 数组中次数超过的数数组中有一个数字出现的次数超过的数数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 可以用hashmap 可以先排序 超过一半，即超过其他数之和。用一个num记录当前count大于零的数，count表示此数的次数，如果新遍历的数不是num，count–，否则count++，当count归零，更新num。 1234567891011121314151617181920public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length == 0) return 0; int num = array[0], count = 1; for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] != num)&#123; if(count == 0) num = array[i]; else count--; &#125;else count++; &#125; if(count &gt; 0) return num; else return 0; &#125;&#125; 30 最小的K个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 1234567891011121314151617181920212223242526272829import java.util.PriorityQueue;import java.util.ArrayList;import java.util.Comparator;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(k &gt; input.length || k == 0) return res; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for(int i = 0; i &lt; input.length; i++)&#123; if(queue.size() &lt; k)&#123; queue.offer(input[i]); &#125;else if(queue.peek() &gt; input[i])&#123; queue.poll(); queue.offer(input[i]); &#125; &#125; while(!queue.isEmpty())&#123; res.add(queue.poll()); &#125; return res; &#125;&#125; 31 连续子数组的最大和HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 123456789101112131415public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int cur = 0; int max = Integer.MIN_VALUE; for(int i = 0; i &lt; array.length; i++)&#123; if(cur &gt; 0) cur += array[i]; else cur = array[i]; if(cur &gt; max) max = cur; &#125; return max; &#125;&#125; 32 整数中1出现的次求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 规律：当计算右数第 i 位包含的 x 的个数时 1. 取第 i位左边(高位)的数字，乘以 10^(i-1)，得到基础值 a 2. 取第 i 位数字，计算修正值 3. 如果大于 x , 则结果为 a + 10^(i-1) 4. 如果小于 x，则结果为 a 5. 如果等于 x，则取第 i 位右边(低位)数字，设为 b，最后结果为 a + b + 1 1234567891011121314151617181920// n - n / i * i 是当前左边一位public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; for(int i = 1; n / i != 0; i *= 10)&#123; int base = n / i / 10 ; base *= i; int bias = n / i % 10; if(bias &lt; 1) count += base; else if(bias &gt; 1) count += base + i; else&#123; count += base + n - n / i * i + 1; &#125; &#125; return count; &#125;&#125; 33 把数组排成最小的数输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 类似冒泡排序 12345678910111213141516171819202122public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int n : numbers)&#123; list.add(String.valueOf(n)); &#125; for(int i = 0;i &lt;list.size(); i++)&#123; for(int j = 0; j &lt; list.size() - 1 - i; j++)&#123; if(Long.parseLong(list.get(j) + list.get(j + 1)) &gt; Long.parseLong(list.get(j + 1) + list.get(j))) &#123; String temp = list.get(j + 1); list.set(j + 1 , list.get(j)); list.set(j, temp); &#125; &#125; &#125; String res = &quot;&quot;; for (String s:list) &#123; res += s; &#125; return res; &#125;&#125; 34 丑数把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516171819import java.util.PriorityQueue;public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index == 0) return 0; PriorityQueue&lt;Long&gt; queue = new PriorityQueue(); queue.offer(1L); long num = 1L; for(int i = 0; i != index; i++)&#123; num = queue.poll(); while(!queue.isEmpty() &amp;&amp; num == queue.peek()) queue.poll(); queue.offer(num * 2); queue.offer(num * 3); queue.offer(num * 5); &#125; return (int)num; &#125;&#125; 35第一个只出现一次的字符在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 123456789101112131415161718import java.util.HashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; char[] cs = str.toCharArray(); HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : cs) &#123; if (!map.containsKey(c)) map.put(c, 1); else map.put(c, map.get(c) + 1); &#125; for (int i = 0; i &lt; cs.length; i++) &#123; if (map.get(cs[i]) == 1) return i; &#125; return -1; &#125;&#125; 36 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 归并排序，注意是从后往前放copy数组。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int InversePairs(int [] array) &#123; if(array.length == 0) return 0; return mergeSort(array, 0, array.length - 1); &#125; private int mergeSort(int[] array, int start, int end)&#123; int mid = (end + start)/ 2; if(end == start) return 0; int leftCount = mergeSort(array, start, mid); int rightCount = mergeSort(array, mid + 1, end); int i = mid, j = end; int count = 0; int index = end - start; int[] copy = new int[end - start + 1]; while(i &gt;= start &amp;&amp; j &gt;= mid + 1)&#123; if(array[i] &gt; array[j])&#123; count = (count + j - mid) % 1000000007; copy[index--] = array[i--]; &#125;else&#123; copy[index--] = array[j--]; &#125; &#125; while(i &gt;= start)&#123; copy[index--] = array[i--]; &#125; while(j &gt;= mid + 1)&#123; copy[index--] = array[j--]; &#125; for(int k = 0; k &lt; copy.length; k++) array[start + k] = copy[k]; return (leftCount + rightCount + count) % 1000000007; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库索引总结 数据库索引索引通常是由B树或者B+树实现。 B树和B+树的区别 B树的键和值也存在内部节点和叶子结点中，B+树内部结点只存键，叶子结点存键和值。 B+树的叶子结点有一条链相连。 B树的好处B树在内部存键值，频繁访问的节点在根节点附近可以提高查询效率，如果特定数据是重复读取，B树更好。 B+树的好处一次读取大量数据时，因为B+树内部节点只存键，因此可以读取更多键，又因为叶子节点有链，读取大量数据时不需要每次都遍历内部节点。 数据库使用B+还不是BB树只适合随机检索，B+树同时适合随机检索和顺序检索。 B+树空间利用率更高，I/O次数少，磁盘读写少。索引也很大，需要以文件的形式存在磁盘中。索引查找就会产生I/O操作。B+树可以一次读取更多的关键字，因此I/O次数少。 B+树查询效率更稳定。B树关键字在内部节点中也有，找到关键字就能确定记录。性能代价相当于二分查找。B+树每次都是跟到叶节点，效率更稳定。 B+树顺序遍历效率也不低。B+树叶子结点有链。 索引类型 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键索引。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：没有唯一性限制，可以为空。 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 联合索引：可以多个列共同创建联合索引。一个查询可以使用其中一个列，但必须遵守最左前缀原则。 聚集索与非聚集索 聚集索引：各行的物理顺序和逻辑顺序相同，一个表只能有一个。 非聚集索引：数据与索引在不同位置，索引中存在指向数据的指针，可以有多个。非聚集索引，分成普通索引，唯一索引，全文索引。 InnoDB的数据文件本身就是索引文件。InnoDB数据文件按聚集索引，所以InnoDB必须有主键。InnoDB聚集索引规则： 如果有主键，主键就是聚集索引。 如果没有主键，第一个唯一非空索引就是聚集索引。 如果1、2都没有，会生成一个隐藏的主键作为聚集索引，它是6个字节的列，随着数据插入自增。 MyISAM和InnoDB索引实现 索引 MyISAM InnoDB 主键索引 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 辅助索引 索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。 索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。 索引的优点 创建唯一性索引，可以确保每行数据的唯一性。 提高数据检索效率。 加快表与表之间的连接。 使用分组和排序字句检索时，可以加快检索时间。 通过使用索引，在查询过程中，使用查询优化器，提高系统性能。 索引的缺点 时间方面：创建和维护需要时间。对数据增删改也需要对索引维护。 空间方面：索引需要占据物理空间。 索引的优化 非空字段：索引的列最好为非空。空值很难优化，用其他方式（0，特殊值等）代替空值。 取离散大的列：将更离散的数据放在联合索引前面。 索引字段越小越好：数据以页为单位存储，一页数据越多，一次IO操作得到的数据越多。 对 where,on,group by,order by 中出现的列使用索引。 对于like查询，%不放在前面。 最左前缀匹配原则。 最左前缀匹配原则mysql会向右匹配到范围查询（&lt;,&gt;,between等），=、in放在左边。 = in 可以乱序。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库范式范式1. 第一范式每个属性都不可再分。 2. 第二范式消除了非主属性对于码的部分函数依赖。所有非主属性都必须和主键有完全依赖关系，不能存在有某个非主属性只和主键的一部分有关。 12345部分函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若存在X&apos;-&gt;Y，则Y部分函数依赖X。安全函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若每个X&apos;！-&gt;Y，则Y完全函数依赖X。传递函数依赖：在关系R(U)中，XYZ是R的三个属性集合，若X确定Y，Y确定Z，X不包含Y，Y不确定Z，(XUY)∩Z为空，则称Z传递函数依赖于X。 3. 第三范式消除了非主属性对于码的传递函数依赖。不仅要满足第二范式，而且所有属性都要互相独立，没有传递关系。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题 3——26]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%203-26%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 3——2603 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718192021//从右上角开始遍历。public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row = array.length; int col = array[0].length; if(row==0 || col==0) return false; int i = 0, j = col - 1; while(array[i][j]!=target)&#123; if(array[i][j]&lt;target)&#123; i++; &#125;else&#123; j--; &#125; if(i &gt; row - 1 || j &lt; 0)&#123; return false; &#125; &#125; return true; &#125;&#125; 04 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String res = ""; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(str.charAt(i)==' ') res = "%20" + res; else res = str.charAt(i) + res; &#125; return res; &#125;&#125; 05 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 123456789101112131415161718192021222324252627282930313233// 用栈 或 反转链表/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); ListNode newHead = null; ListNode left = null; ListNode now = listNode; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; while(newHead != null)&#123; res.add(newHead.val); newHead = newHead.next; &#125; return res; &#125;&#125; 06 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length == 0)&#123; return null; &#125; TreeNode root = new TreeNode(pre[0]); int mid = 0; for(int i = 0;i &lt; in.length;i++)&#123; if(in[i] == pre[0]) mid = i; &#125; root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, 1 + mid), Arrays.copyOfRange(in, 0, mid)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, 1 + mid, pre.length), Arrays.copyOfRange(in, mid + 1, in.length)); return root; &#125;&#125; 07 两个栈实现队列123456789101112131415161718192021import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; int num = stack1.pop(); stack2.push(num); &#125; &#125; return stack2.pop(); &#125;&#125; 08 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415161718192021import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; int low = 0; int mid = (array.length + low) / 2; int high = array.length - 1; while(low &lt; high)&#123; mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if (array[mid] &lt; array[high])&#123; high = mid; &#125;else&#123; high--; &#125; &#125; return array[low]; &#125;&#125; 09 斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 1234567891011121314151617181920212223// 使用动态规划public class Solution &#123; public int Fibonacci(int n) &#123; int f1 = 0; int f2 = 1; int index = 0; int res = 0; while(index &lt;= n)&#123; if(index == 0)&#123; res = f1; &#125;else if(index == 1)&#123; res = f2; &#125; else&#123; res = f1 + f2; f1 = f2; f2 = res; &#125; index ++; &#125; return res; &#125;&#125; 10 二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 123456789101112131415161718192021222324// 自己写的public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; for(int i = 0; i &lt; 32; i++)&#123; if((n &amp; 1) == 1)&#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count; &#125;&#125;// 网上更简练的，n按位与n-1，可以将最后一个1变成0public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; count += 1; n &amp;= (n-1); &#125; return count; &#125;&#125; 11 数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516// &amp; 1 判断奇偶public class Solution &#123; public double Power(double base, int exponent) &#123; if(base == 0) return 0; if(exponent == 0) return 1; if(exponent &lt; 0) return 1 / Power(base, exponent * (-1)); if((exponent &amp; 1) == 1)&#123; return base * Power(base, exponent / 2) * Power(base, exponent / 2); &#125;else&#123; return Power(base, exponent / 2) * Power(base, exponent / 2); &#125; &#125;&#125; 14 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819202122// 不开空间，用指针也比较麻烦，时间复杂度也不低，没找到指针比较好的办法import java.util.List;import java.util.ArrayList;public class Solution &#123; public void reOrderArray(int [] array) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; array.length; i++)&#123; if((array[i] &amp; 1) == 1)&#123; list1.add(array[i]); &#125;else&#123; list2.add(array[i]); &#125; &#125; List&lt;Integer&gt; listAll = new ArrayList&lt;Integer&gt;(); listAll.addAll(list1); listAll.addAll(list2); for(int i = 0; i &lt; array.length; i++)&#123; array[i] = listAll.get(i); &#125; &#125;&#125; 15 输入一个链表，输出该链表中倒数第k个结点链表中倒数第k个结点 12if(right == null) return null; 注意这句的位置，要放在right = right.next;前面，否则{1,2,3,4,5},5/6 会有问题。12345678910111213141516171819202122232425262728/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(k == 0 || head == null) return null; int index = 0; ListNode right = head; for(int i = 0;i &lt; k; i++)&#123; if(right == null) return null; right = right.next; &#125; ListNode left = head; while(right != null)&#123; right = right.next; left = left.next; &#125; return left; &#125;&#125;## 16 反转链表输入一个链表，反转链表后，输出新链表的表头。要注意 now = now.next; newHead.next = left;的先后顺序 123456789101112131415161718192021222324252627// 要注意 now = now.next; newHead.next = left;的先后顺序/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode newHead = null; ListNode left = null; ListNode now = head; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; return newHead; &#125;&#125; 17 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/// 非递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode head = new ListNode(-1); ListNode now = head; while(list1 != null &amp;&amp; list2 != null)&#123; if(list1.val &lt; list2.val)&#123; now.next = list1; list1 = list1.next; &#125; else&#123; now.next = list2; list2 = list2.next; &#125; now = now.next; &#125; if(list1 != null) now.next = list1; if(list2 != null) now.next = list2; return head.next; &#125;&#125;// 递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode node = list1; if(list1.val &lt; list2.val)&#123; node = list1; node.next = Merge(list1.next, list2); &#125;else&#123; node = list2; node.next = Merge(list1, list2.next); &#125; return node; &#125;&#125; 18 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425262728293031323334/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2 == null || root1 == null) return false; return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1, TreeNode root2) &#123; if(root2 == null)&#123; return true; &#125; if(root1 == null) return false; if(root1.val == root2.val)&#123; return isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right); &#125;else&#123; return false; &#125; &#125;&#125; 19 二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112131415161718192021222324/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; TreeNode node = root.left; root.left = root.right; root.right = node; Mirror(root.left); Mirror(root.right); &#125;&#125; 20 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if(matrix.length == 0 || matrix[0].length == 0) return null; int row = matrix.length, col = matrix[0].length; int top = 0, left = 0, right = col - 1, buttom = row - 1; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); while(left &lt;= right &amp;&amp; top &lt;= buttom)&#123; for(int i = left; i &lt;= right; i++)&#123; res.add(matrix[top][i]); &#125; for(int i = top + 1; i &lt;= buttom; i++)&#123; res.add(matrix[i][right]); &#125; if(top != buttom) for(int i = right - 1; i &gt;= left; i--)&#123; res.add(matrix[buttom][i]); &#125; if(left != right) for(int i = buttom - 1; i &gt; top; i--)&#123; res.add(matrix[i][left]); &#125; left++;top++;right--;buttom--; &#125; return res; &#125;&#125; 21 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); int min = node; if(!minStack.isEmpty()) min = minStack.pop(); minStack.push(min); if(node &lt; min) min = node; minStack.push(min); &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; int num = stack.pop(); stack.push(num); return num; &#125; public int min() &#123; int num = minStack.pop(); minStack.push(num); return num; &#125;&#125; 22 栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length != popA.length || pushA.length == 0 || popA.length == 0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int index = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); while(stack.peek() == popA[index])&#123; stack.pop(); index++; if(index == popA.length) return true; &#125; &#125; return false; &#125;&#125; 23 从上往下打出二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); res.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; &#125; return res; &#125;&#125; 24 二叉搜索树的后序遍历输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0) return false; return judge(sequence, 0, sequence.length -1 ); &#125; private boolean judge(int[] sequence, int start ,int end)&#123; int root = end; int i = start; if(start &gt;= end) return true; while(i &lt; end &amp;&amp; sequence[i] &lt; sequence[end]) i++; for(int j = i; j &lt; end; j++)&#123; if(sequence[j] &lt; sequence[end]) return false; &#125; return judge(sequence, start, i - 1 ) &amp;&amp; judge(sequence, i, end - 1); &#125;&#125; 25 二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); if(target &gt; 0 &amp;&amp; root != null) find(root, target, array); return res; &#125; private void find(TreeNode root,int target, ArrayList&lt;Integer&gt; array)&#123; array.add(root.val); target = target - root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add((ArrayList&lt;Integer&gt;)array.clone()); else &#123; if(root.left != null) find(root.left, target, array); if(root.right != null) find(root.right, target, array); &#125; array.remove(array.size() - 1); &#125;&#125; 26 复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） “输出结果中请不要返回参数中的节点引用”，在第三步时，就要RandomListNode newNode。 12345678910111213141516171819202122232425262728293031323334353637383940/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) return null; RandomListNode node = pHead; while(node != null)&#123; RandomListNode newNode = new RandomListNode(node.label); newNode.next = node.next; node.next = newNode; node = node.next.next; &#125; node = pHead; while(node != null)&#123; if(node.random != null) node.next.random = node.random.next; node = node.next.next; &#125; node = pHead; RandomListNode newHead = node.next; while(node != null)&#123; RandomListNode newNode = node.next; node.next = node.next.next; newNode.next = newNode.next == null? null: newNode.next.next; node = node.next; &#125; return newHead; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ShadowSocks]]></title>
    <url>%2F2018%2F09%2F21%2F%E6%90%AD%E5%BB%BAShadowSocks%2F</url>
    <content type="text"><![CDATA[搭建ShadowSocks客户端下载https://shadowsocks.org/en/download/clients.html ss的配制与使用 检查Python版本 1$ python –version 安装m2crypto和python-setuptools 1$ yum install m2crypto python-setuptools 安装pip 1yum -y install python-pip 或者（没试过）1$ easy_install pip 安装ss 1$ pip shadowsocks 配置服务器参数 1$ vi /etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, //服务器的IP地址 &quot;server_port&quot;:7711, //服务器的端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, //本机IP地址 &quot;local_port&quot;:1080, //本机端口 &quot;password&quot;:&quot;mypassword&quot;, //自己设定的密码 &quot;timeout&quot;:300, //超出时间 &quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方法，推荐使用&quot;aes-256-cfb&quot; &quot;fast_open&quot;: false //true 或 false&#125;&#125; 若是多用户模式，将server_port和password合并为port_password： 1234&quot;port_password&quot;: &#123; &quot;443&quot;: &quot; mypassword 1”, //对应端口设定不同的密码 &quot;8888&quot;: &quot; mypassword 2” &#125;, 安装gevent Gevent可以提高ss性能，由于gevent依赖于libevent和greenlet 123$ yum install -y libevent$ pip install greenlet$ pip install gevent 配置防火墙 为了提高系统的安全性，需要安装防火墙 1$ yum install firewalld 启动防火墙 1$ systemctl start firewalld 开启相应端口 12$ firewall-cmd --permanent --zone=public --add-port=443/tcp$ firewall-cmd –reload 查看修改ss服务器的端口密码 查看当前ss服务器所开放的端口 1ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件，配置文件中自然有密码 1ps aux | grep ssserver 用cat查看下配置文件即可看见密码了，vim修改 1vim /etc/shadowsocks.json ss启动停止方法 启动，停止，重启，状态：1234567service shadowsocks startservice shadowsocks stopservice shadowsocks restartservice shadowsocks status 参考：https://github.com/easonhuang123/blog/issues/1https://blog.whsir.com/post-1045.html]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件夹中添加-右键打开命令行窗口（转载）]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[将“在此处打开命令窗口”添加到右键菜单（转载）注册表编辑器中 \HKEY_CLASSES_ROOT\Directory\shell\ \HKEY_CLASSES_ROOT\Directory\Background\shell\ \HKEY_CLASSES_ROOT\Drive\shell\ \HKEY_CLASSES_ROOT\LibraryFolder\background\（要新建shell项） 上述项中每个都执行的步骤： 放在\shell\上，右键，选择新建-项：OpenCmdHere 进入OpenCmdHere，修改值为OpenCmdHere 选择新建-字符串值：Icon \OpenCmdHere，新建-项：command 进入command，修改值为： 1Powershell -windowstyle hidden -Command &quot;Start-Process cmd.exe -ArgumentList &apos;/s,/k, pushd,%V&apos; -Verb RunAs&quot; 原贴地址：https://www.ithome.com/html/win10/309633.htm]]></content>
      <categories>
        <category>Windows tips</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳Python脚本]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3python%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[微信跳一跳Python脚本adb+python，用的话先装adb， 感觉80%能跳到中心吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# -*- coding: utf-8 -*-import timefrom PIL import Imageimport osimport mathdef isPixFuzzyDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 10 and abs(g - pix[1]) &lt; 10 and abs(b - pix[2]) &lt; 10: return False else: return Truedef isPixAccurateDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 1 and abs(g - pix[1]) &lt; 1 and abs(b - pix[2]) &lt; 1: return False else: return Truedef isWhiteCenter(pix): if pix[0] == 245 and pix[1] == 245 and pix[2] ==245: return True else: return False def getDistance(dep,des): if des[0] &gt; dep[0]: x1,x2 = des[0],dep[0] else: x2,x1 = des[0],dep[0] x = (x1 - x2) y = (dep[1] - des[1])/2 dis = (x**2+y**2)**0.5 return disdef getTopPixel(pix,height,width,depPix): topPixel = [0,0] if depPix[0] &lt; width/2: startpoint = depPix[0] + 40 endpoint = width - 2 else: startpoint = 40 endpoint = depPix[0] - 40 deltaX = x0 = 0 flag = False for y in range(int(0.18 * height),int(0.66 * height)): for x in range(startpoint,endpoint): if x == startpoint: r, g, b = pix[x, y][0:3] elif isPixFuzzyDiff(r,g,b,pix[x,y]): r, g, b = pix[x, y][0:3] flag = not flag if not flag: break x0 = x elif flag : deltaX += 1 else: continue break print deltaX topPixel = [x0 + math.floor(deltaX)/2,y] return topPixel# button == buttom 懒得改def getButtonPixel(topPixel,pix): buttonPixel = [topPixel[0],0] r, g, b = pix[topPixel[0],topPixel[1]][0:3] for y in range(topPixel[1],topPixel[1] + 250): if not isPixAccurateDiff(r,g,b,pix[topPixel[0],y]): buttonPixel[1] = y return buttonPixeldef getdepPix(pix,height,width): depPix = [0,0] for y in range(1388,200,-1): for x in range(2,width-2): if isPixAccurateDiff(54,60,102,pix[x,y]): continue else: depPix = [x,y] break else: continue break return depPixdef main(): for i in range(20): filename = str(int(time.time())) + '.png' time.sleep(2) print "filename: " + filename time.sleep(2) os.system('adb shell /system/bin/screencap -p /sdcard/jump/' + filename) print "screencap" time.sleep(2) os.system('adb pull /sdcard/jump/' + filename + ' d:/MyCode/Python/jump/' + filename) print "pull"## filename = '1515321961' + '.png' im = Image.open(filename) pix = im.load() width = im.size[0] height = im.size[1] depPix = getdepPix(pix,height,width) topPixel = getTopPixel(pix,height,width,depPix) buttonPixel = getButtonPixel(topPixel,pix) desPix = [topPixel[0],(buttonPixel[1] - topPixel[1])/2 + topPixel[1]] print topPixel print buttonPixel print desPix print depPix dis = getDistance(depPix,desPix) print "distance: " + str(dis) swipeTime = 722/475.1 * dis print "swipeTime:" + str(swipeTime) os.system("adb shell input swipe 250 250 300 300 " + str(int(swipeTime))) if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda序列化问题]]></title>
    <url>%2F2017%2F12%2F12%2FLambda%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Lambda序列化问题这几天用spark遇到一个问题，到现在仍没有解决，不过查到了一些思路，可能与序列化有关。 先上代码1234567891011//不用Lambda，没有问题lines.mapToPair(new PairFunction&lt;String, Integer, Integer&gt;() &#123; private static final long serialVersionUID = 1323L; @Override public Tuple2&lt;Integer, Integer&gt; call(String word) throws Exception &#123; return new Tuple2&lt;Integer, Integer&gt;(1, 1); &#125; &#125;).take(200).forEach(v -&gt; System.out.println(v));//用lambda，报错lines.mapToPair(v -&gt; new Tuple2&lt;Integer, Integer&gt;(1, 1)).take(200).forEach(v -&gt; System.out.println(v)); 错误信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495017/12/12 16:00:53 WARN TaskSetManager: Lost task 0.0 in stage 1.0 (TID 1, 10.103.244.216): java.io.IOException: unexpected exception type at java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1582) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1154) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2022) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422) at org.apache.spark.serializer.JavaDeserializationStream.readObject(JavaSerializer.scala:76) at org.apache.spark.serializer.JavaSerializerInstance.deserialize(JavaSerializer.scala:115) at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:61) at org.apache.spark.scheduler.Task.run(Task.scala:89) at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:213) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: java.lang.NoSuchMethodException: TestSUANZI.test.$deserializeLambda$(java.lang.invoke.SerializedLambda) at java.lang.Class.getDeclaredMethod(Class.java:2130) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:224) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:221) at java.security.AccessController.doPrivileged(Native Method) at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:221) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1148) ... 27 more17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.1 in stage 1.0 (TID 2, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.1 in stage 1.0 (TID 2) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 1]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.2 in stage 1.0 (TID 3, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.2 in stage 1.0 (TID 3) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 2]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.3 in stage 1.0 (TID 4, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.3 in stage 1.0 (TID 4) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 3]17/12/12 16:00:53 ERROR TaskSetManager: Task 0 in stage 1.0 failed 4 times; aborting job 目前的解决方法是实现Serializable这个接口。 有时间读一下https://www.zhihu.com/question/51491241/answer/126232275]]></content>
      <categories>
        <category>Lambda表达式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrapyDemo]]></title>
    <url>%2F2017%2F11%2F30%2FScrapyDemo%2F</url>
    <content type="text"><![CDATA[建立工程 scrapy startproject scrapydemo 目录分析 scrapy.cfg: 项目的配置文件 scrapytest/: 该项目的python模块。之后您将在此加入代码。 scrapytest/items.py: 项目中的item文件. scrapytest/pipelines.py: 项目中的pipelines文件. scrapytest/settings.py: 项目的设置文件. scrapytest/spiders/: 放置spider代码的目录. Tips1. spider name/spiders/目录下创建一个文件-name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 2.多级抓取scrapy 在不同的抓取级别的Request之间传递参数的办法，下面的范例中，parse()通过meat传递给了parse_more()参数item，这样就可以再parse_more()抓取完成所有的数据后一次返123456789def parse(self, response): …… item['url'] = url.extract()[0] for item in items: yield Request(url = item['url'],meta = &#123;'item':item&#125;, callback = self.parse_more,dont_filter = True)def parse_more(self,response): item = response.meta['item'] …… yield item 总结需要修改demo的地方demo地址:https://github.com/CherryKeinz/ScrapyDemo 1. items.py修改类demoItem()里需要的字段 2. /spiders/MySpider.pyimport 要改为items.py中定义的类名from SpiderDemo.items import demoItem allowed_domains = [“http://10.3.210.84:4237/home/“]这个是 spider要求设置的一个变量,表示允许爬虫爬的网站 start_urls.append(url) url改为要爬的网址 如需保存为JSON，修改custom_settings 3.pipelines.py如需要，修改类JsonWithEncodingPipeline 常见错误 scrapy 报错 no module named win32api 的解决方案原因是缺少win32,到 http://sourceforge.net/projects/pywin32/files/找到对应的版本进行下载，直接安装即可]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo nexT的一些玩法（转载+总结）]]></title>
    <url>%2F2017%2F11%2F22%2FHexo-nexT%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础篇1. 常用命令12345678hexo new &quot;HelloWorld&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo d #部署 #可与hexo g合并为 hexo d -g 2. 文章中插入图片对于hexo，有两种方式：使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。使用微博图床，地址 http://weibotuchuang.sinaapp.com/ ，将图片拖入区域中，会生成图片的URL，这就是链接地址。 3. 添加分页、标签页面 新建命令： hexo new page tags # tags可替换成其他 输入命令后，在/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件。在上步新生成的myBlog/source/tags/index.md中添加type: “tags”，index.md文件内容如下：设置具体文章的tags当要为某一篇文章添加标签，只需在/source/_post目录下的具体文章的tags中添加标签即可，如： tags: [hexo,next] 4. 引入第三方服务参考 : http://theme-next.iissnan.com/third-party-services.html#swfitype 加入分享功能在主题配置文件中，jiathis: true 加入评论功能待续 加入站点内容搜索功能1) 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb –save 2) 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 3) 编辑 主题配置文件，启用本地搜索功能： 1enable: true 数据统计 待续 个性化 (参考)1. 修改文章内链接文本样式（待考证）修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 2. 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成/&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;/ 3. 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 3. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：class12 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;&lt;/span&gt; 然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 4. 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，修改为 :123456&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;/&gt;&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;&#123;&#123; theme.android_chrome_color &#125;&#125;&quot;&gt; 参考资料：http://www.jianshu.com/p/c23902f93558http://blog.csdn.net/qq_33699981/article/details/72716951http://playingfingers.com/2016/03/26/build-a-blog/https://segmentfault.com/a/1190000003946969]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
