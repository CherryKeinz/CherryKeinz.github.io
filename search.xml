<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer算法题 27——30]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%2027-30%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 27——3027 二叉搜索树转换成双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 “不能创建任何新的结点”，但是需要new tail new tail 递归或栈的方法中序遍历。 1234567891011121314151617181920212223242526272829303132333435363738/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; TreeNode head = null; TreeNode tail = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if(pRootOfTree == null) return null; ConvertNode(pRootOfTree); return head; &#125; private void ConvertNode(TreeNode node)&#123; if(node == null) return; ConvertNode(node.left); if(head == null)&#123; head = node; tail = node; &#125;else&#123; tail.right = node; node.left = tail; tail = node; &#125; ConvertNode(node.right); &#125;&#125; 28 字符串排列输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 按字典序打印，需要把结果：Collections.sort(res); 避免重复的，需要判断：if(i != index &amp;&amp; chars[i] == chars[index]) 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;public class Solution &#123; ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); public ArrayList&lt;String&gt; Permutation(String str) &#123; char[] chars = str.toCharArray(); if(str.length() == 0) return res; res = Permutation(chars, 0); Collections.sort(res); return res; &#125; private ArrayList&lt;String&gt; Permutation(char[] chars, int index)&#123; if(index == chars.length - 1) res.add(String.valueOf(chars)); else&#123; for(int i = index; i &lt; chars.length; i++)&#123; if(i != index &amp;&amp; chars[i] == chars[index])&#123; continue; &#125; swap(chars, i, index); Permutation(chars, index + 1); swap(chars, index, i); &#125; &#125; return res; &#125; private void swap(char[] chars, int i ,int j)&#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125;&#125; 29 数组中次数超过的数数组中有一个数字出现的次数超过的数数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 可以用hashmap 可以先排序 超过一半，即超过其他数之和。用一个num记录当前count大于零的数，count表示此数的次数，如果新遍历的数不是num，count–，否则count++，当count归零，更新num。 1234567891011121314151617181920public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array.length == 0) return 0; int num = array[0], count = 1; for(int i = 1; i &lt; array.length; i++)&#123; if(array[i] != num)&#123; if(count == 0) num = array[i]; else count--; &#125;else count++; &#125; if(count &gt; 0) return num; else return 0; &#125;&#125; 30 最小的K个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 1234567891011121314151617181920212223242526272829import java.util.PriorityQueue;import java.util.ArrayList;import java.util.Comparator;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(k &gt; input.length || k == 0) return res; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(k, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); for(int i = 0; i &lt; input.length; i++)&#123; if(queue.size() &lt; k)&#123; queue.offer(input[i]); &#125;else if(queue.peek() &gt; input[i])&#123; queue.poll(); queue.offer(input[i]); &#125; &#125; while(!queue.isEmpty())&#123; res.add(queue.poll()); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库索引总结 数据库索引索引通常是由B树或者B+树实现。 B树和B+树的区别 B树的键和值也存在内部节点和叶子结点中，B+树内部结点只存键，叶子结点存键和值。 B+树的叶子结点有一条链相连。 B树的好处B树在内部存键值，频繁访问的节点在根节点附近可以提高查询效率，如果特定数据是重复读取，B树更好。 B+树的好处一次读取大量数据时，因为B+树内部节点只存键，因此可以读取更多键，又因为叶子节点有链，读取大量数据时不需要每次都遍历内部节点。 数据库使用B+还不是BB树只适合随机检索，B+树同时适合随机检索和顺序检索。 B+树空间利用率更高，I/O次数少，磁盘读写少。索引也很大，需要以文件的形式存在磁盘中。索引查找就会产生I/O操作。B+树可以一次读取更多的关键字，因此I/O次数少。 B+树查询效率更稳定。B树关键字在内部节点中也有，找到关键字就能确定记录。性能代价相当于二分查找。B+树每次都是跟到叶节点，效率更稳定。 B+树顺序遍历效率也不低。B+树叶子结点有链。 索引类型 主键索引：数据列不允许重复，不允许为null，一个表只能有一个主键索引。 唯一索引：数据列不允许重复，允许为null，一个表允许多个列创建唯一索引。 普通索引：没有唯一性限制，可以为空。 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。 联合索引：可以多个列共同创建联合索引。一个查询可以使用其中一个列，但必须遵守最左前缀原则。 聚集索与非聚集索 聚集索引：各行的物理顺序和逻辑顺序相同，一个表只能有一个。 非聚集索引：数据与索引在不同位置，索引中存在指向数据的指针，可以有多个。非聚集索引，分成普通索引，唯一索引，全文索引。 InnoDB的数据文件本身就是索引文件。InnoDB数据文件按聚集索引，所以InnoDB必须有主键。InnoDB聚集索引规则： 如果有主键，主键就是聚集索引。 如果没有主键，第一个唯一非空索引就是聚集索引。 如果1、2都没有，会生成一个隐藏的主键作为聚集索引，它是6个字节的列，随着数据插入自增。 MyISAM和InnoDB索引实现 索引 MyISAM InnoDB 主键索引 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 在主键索引中，索引页中存放的是主键和指向数据页的偏移量；数据页中存放的是主键和该主键所属行记录的地址空间。 辅助索引 索引页仍然存放主键和和指向数据页的偏移量，但数据页存放的是完整的记录。 索引节点存放的内容一样，仍然是键值信息和指向数据页的偏移量；但数据页中存放的是键值信息和该键值对应的主键。然后通过主键查询主键索引就能找到该条记录。 索引的优点 创建唯一性索引，可以确保每行数据的唯一性。 提高数据检索效率。 加快表与表之间的连接。 使用分组和排序字句检索时，可以加快检索时间。 通过使用索引，在查询过程中，使用查询优化器，提高系统性能。 索引的缺点 时间方面：创建和维护需要时间。对数据增删改也需要对索引维护。 空间方面：索引需要占据物理空间。 索引的优化 非空字段：索引的列最好为非空。空值很难优化，用其他方式（0，特殊值等）代替空值。 取离散大的列：将更离散的数据放在联合索引前面。 索引字段越小越好：数据以页为单位存储，一页数据越多，一次IO操作得到的数据越多。 对 where,on,group by,order by 中出现的列使用索引。 对于like查询，%不放在前面。 最左前缀匹配原则。 最左前缀匹配原则mysql会向右匹配到范围查询（&lt;,&gt;,between等），=、in放在左边。 = in 可以乱序。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库范式总结]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[数据库范式范式1. 第一范式每个属性都不可再分。 2. 第二范式消除了非主属性对于码的部分函数依赖。所有非主属性都必须和主键有完全依赖关系，不能存在有某个非主属性只和主键的一部分有关。 12345部分函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若存在X&apos;-&gt;Y，则Y部分函数依赖X。安全函数依赖：若XY是关系R中的属性，X-&gt;Y，X&apos;是X的子集，若每个X&apos;！-&gt;Y，则Y完全函数依赖X。传递函数依赖：在关系R(U)中，XYZ是R的三个属性集合，若X确定Y，Y确定Z，X不包含Y，Y不确定Z，(XUY)∩Z为空，则称Z传递函数依赖于X。 3. 第三范式消除了非主属性对于码的传递函数依赖。不仅要满足第二范式，而且所有属性都要互相独立，没有传递关系。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>面试</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题 3——26]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98%203-26%2F</url>
    <content type="text"><![CDATA[剑指offer算法题 3——2603 二维数组中的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718192021//从右上角开始遍历。public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int row = array.length; int col = array[0].length; if(row==0 || col==0) return false; int i = 0, j = col - 1; while(array[i][j]!=target)&#123; if(array[i][j]&lt;target)&#123; i++; &#125;else&#123; j--; &#125; if(i &gt; row - 1 || j &lt; 0)&#123; return false; &#125; &#125; return true; &#125;&#125; 04 替换空格请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String res = ""; for(int i=str.length()-1;i&gt;=0;i--)&#123; if(str.charAt(i)==' ') res = "%20" + res; else res = str.charAt(i) + res; &#125; return res; &#125;&#125; 05 从尾到头打印链表输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 123456789101112131415161718192021222324252627282930313233// 用栈 或 反转链表/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); ListNode newHead = null; ListNode left = null; ListNode now = listNode; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; while(newHead != null)&#123; res.add(newHead.val); newHead = newHead.next; &#125; return res; &#125;&#125; 06 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.Arrays;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length == 0)&#123; return null; &#125; TreeNode root = new TreeNode(pre[0]); int mid = 0; for(int i = 0;i &lt; in.length;i++)&#123; if(in[i] == pre[0]) mid = i; &#125; root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, 1 + mid), Arrays.copyOfRange(in, 0, mid)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, 1 + mid, pre.length), Arrays.copyOfRange(in, mid + 1, in.length)); return root; &#125;&#125; 07 两个栈实现队列123456789101112131415161718192021import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if(stack2.isEmpty())&#123; while(!stack1.isEmpty())&#123; int num = stack1.pop(); stack2.push(num); &#125; &#125; return stack2.pop(); &#125;&#125; 08 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 123456789101112131415161718192021import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; int low = 0; int mid = (array.length + low) / 2; int high = array.length - 1; while(low &lt; high)&#123; mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if (array[mid] &lt; array[high])&#123; high = mid; &#125;else&#123; high--; &#125; &#125; return array[low]; &#125;&#125; 09 斐波那契数列大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 1234567891011121314151617181920212223// 使用动态规划public class Solution &#123; public int Fibonacci(int n) &#123; int f1 = 0; int f2 = 1; int index = 0; int res = 0; while(index &lt;= n)&#123; if(index == 0)&#123; res = f1; &#125;else if(index == 1)&#123; res = f2; &#125; else&#123; res = f1 + f2; f1 = f2; f2 = res; &#125; index ++; &#125; return res; &#125;&#125; 10 二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 123456789101112131415161718192021222324// 自己写的public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; for(int i = 0; i &lt; 32; i++)&#123; if((n &amp; 1) == 1)&#123; count++; &#125; n = n &gt;&gt; 1; &#125; return count; &#125;&#125;// 网上更简练的，n按位与n-1，可以将最后一个1变成0public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; count += 1; n &amp;= (n-1); &#125; return count; &#125;&#125; 11 数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516// &amp; 1 判断奇偶public class Solution &#123; public double Power(double base, int exponent) &#123; if(base == 0) return 0; if(exponent == 0) return 1; if(exponent &lt; 0) return 1 / Power(base, exponent * (-1)); if((exponent &amp; 1) == 1)&#123; return base * Power(base, exponent / 2) * Power(base, exponent / 2); &#125;else&#123; return Power(base, exponent / 2) * Power(base, exponent / 2); &#125; &#125;&#125; 14 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 12345678910111213141516171819202122// 不开空间，用指针也比较麻烦，时间复杂度也不低，没找到指针比较好的办法import java.util.List;import java.util.ArrayList;public class Solution &#123; public void reOrderArray(int [] array) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; array.length; i++)&#123; if((array[i] &amp; 1) == 1)&#123; list1.add(array[i]); &#125;else&#123; list2.add(array[i]); &#125; &#125; List&lt;Integer&gt; listAll = new ArrayList&lt;Integer&gt;(); listAll.addAll(list1); listAll.addAll(list2); for(int i = 0; i &lt; array.length; i++)&#123; array[i] = listAll.get(i); &#125; &#125;&#125; 15 输入一个链表，输出该链表中倒数第k个结点链表中倒数第k个结点 12if(right == null) return null; 注意这句的位置，要放在right = right.next;前面，否则{1,2,3,4,5},5/6 会有问题。12345678910111213141516171819202122232425262728/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(k == 0 || head == null) return null; int index = 0; ListNode right = head; for(int i = 0;i &lt; k; i++)&#123; if(right == null) return null; right = right.next; &#125; ListNode left = head; while(right != null)&#123; right = right.next; left = left.next; &#125; return left; &#125;&#125;## 16 反转链表输入一个链表，反转链表后，输出新链表的表头。要注意 now = now.next; newHead.next = left;的先后顺序 123456789101112131415161718192021222324252627// 要注意 now = now.next; newHead.next = left;的先后顺序/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode newHead = null; ListNode left = null; ListNode now = head; while(now != null)&#123; left = newHead; newHead = now; now = now.next; newHead.next = left; &#125; return newHead; &#125;&#125; 17 合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/// 非递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode head = new ListNode(-1); ListNode now = head; while(list1 != null &amp;&amp; list2 != null)&#123; if(list1.val &lt; list2.val)&#123; now.next = list1; list1 = list1.next; &#125; else&#123; now.next = list2; list2 = list2.next; &#125; now = now.next; &#125; if(list1 != null) now.next = list1; if(list2 != null) now.next = list2; return head.next; &#125;&#125;// 递归public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode node = list1; if(list1.val &lt; list2.val)&#123; node = list1; node.next = Merge(list1.next, list2); &#125;else&#123; node = list2; node.next = Merge(list1, list2.next); &#125; return node; &#125;&#125; 18 树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425262728293031323334/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; if(root2 == null || root1 == null) return false; return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean isSubtree(TreeNode root1, TreeNode root2) &#123; if(root2 == null)&#123; return true; &#125; if(root1 == null) return false; if(root1.val == root2.val)&#123; return isSubtree(root1.left, root2.left) &amp;&amp; isSubtree(root1.right, root2.right); &#125;else&#123; return false; &#125; &#125;&#125; 19 二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112131415161718192021222324/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; TreeNode node = root.left; root.left = root.right; root.right = node; Mirror(root.left); Mirror(root.right); &#125;&#125; 20 顺时针打印矩阵输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if(matrix.length == 0 || matrix[0].length == 0) return null; int row = matrix.length, col = matrix[0].length; int top = 0, left = 0, right = col - 1, buttom = row - 1; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); while(left &lt;= right &amp;&amp; top &lt;= buttom)&#123; for(int i = left; i &lt;= right; i++)&#123; res.add(matrix[top][i]); &#125; for(int i = top + 1; i &lt;= buttom; i++)&#123; res.add(matrix[i][right]); &#125; if(top != buttom) for(int i = right - 1; i &gt;= left; i--)&#123; res.add(matrix[buttom][i]); &#125; if(left != right) for(int i = buttom - 1; i &gt; top; i--)&#123; res.add(matrix[i][left]); &#125; left++;top++;right--;buttom--; &#125; return res; &#125;&#125; 21 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 12345678910111213141516171819202122232425262728293031323334import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; minStack = new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); int min = node; if(!minStack.isEmpty()) min = minStack.pop(); minStack.push(min); if(node &lt; min) min = node; minStack.push(min); &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; int num = stack.pop(); stack.push(num); return num; &#125; public int min() &#123; int num = minStack.pop(); minStack.push(num); return num; &#125;&#125; 22 栈的压入、弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length != popA.length || pushA.length == 0 || popA.length == 0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int index = 0; for(int i = 0; i &lt; pushA.length; i++)&#123; stack.push(pushA[i]); while(stack.peek() == popA[index])&#123; stack.pop(); index++; if(index == popA.length) return true; &#125; &#125; return false; &#125;&#125; 23 从上往下打出二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Queue;import java.util.LinkedList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if(root == null) return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); res.add(node.val); if(node.left != null) queue.offer(node.left); if(node.right != null) queue.offer(node.right); &#125; &#125; return res; &#125;&#125; 24 二叉搜索树的后序遍历输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 1234567891011121314151617181920public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0) return false; return judge(sequence, 0, sequence.length -1 ); &#125; private boolean judge(int[] sequence, int start ,int end)&#123; int root = end; int i = start; if(start &gt;= end) return true; while(i &lt; end &amp;&amp; sequence[i] &lt; sequence[end]) i++; for(int j = i; j &lt; end; j++)&#123; if(sequence[j] &lt; sequence[end]) return false; &#125; return judge(sequence, start, i - 1 ) &amp;&amp; judge(sequence, i, end - 1); &#125;&#125; 25 二叉树中和为某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); if(target &gt; 0 &amp;&amp; root != null) find(root, target, array); return res; &#125; private void find(TreeNode root,int target, ArrayList&lt;Integer&gt; array)&#123; array.add(root.val); target = target - root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) res.add((ArrayList&lt;Integer&gt;)array.clone()); else &#123; if(root.left != null) find(root.left, target, array); if(root.right != null) find(root.right, target, array); &#125; array.remove(array.size() - 1); &#125;&#125; 26 复杂链表的复制输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） “输出结果中请不要返回参数中的节点引用”，在第三步时，就要RandomListNode newNode。 12345678910111213141516171819202122232425262728293031323334353637383940/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) return null; RandomListNode node = pHead; while(node != null)&#123; RandomListNode newNode = new RandomListNode(node.label); newNode.next = node.next; node.next = newNode; node = node.next.next; &#125; node = pHead; while(node != null)&#123; if(node.random != null) node.next.random = node.random.next; node = node.next.next; &#125; node = pHead; RandomListNode newHead = node.next; while(node != null)&#123; RandomListNode newNode = node.next; node.next = node.next.next; newNode.next = newNode.next == null? null: newNode.next.next; node = node.next; &#125; return newHead; &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件夹中添加-右键打开命令行窗口（转载）]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[将“在此处打开命令窗口”添加到右键菜单（转载）注册表编辑器中 \HKEY_CLASSES_ROOT\Directory\shell\ \HKEY_CLASSES_ROOT\Directory\Background\shell\ \HKEY_CLASSES_ROOT\Drive\shell\ \HKEY_CLASSES_ROOT\LibraryFolder\background\（要新建shell项） 上述项中每个都执行的步骤： 放在\shell\上，右键，选择新建-项：OpenCmdHere 进入OpenCmdHere，修改值为OpenCmdHere 选择新建-字符串值：Icon \OpenCmdHere，新建-项：command 进入command，修改值为： 1Powershell -windowstyle hidden -Command &quot;Start-Process cmd.exe -ArgumentList &apos;/s,/k, pushd,%V&apos; -Verb RunAs&quot; 原贴地址：https://www.ithome.com/html/win10/309633.htm]]></content>
      <categories>
        <category>Windows tips</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ShadowSocks]]></title>
    <url>%2F2018%2F06%2F26%2F%E6%90%AD%E5%BB%BAShadowSocks%2F</url>
    <content type="text"><![CDATA[搭建ShadowSocks客户端下载https://shadowsocks.org/en/download/clients.html ss的配制与使用 检查Python版本 1$ python –version 安装m2crypto和python-setuptools 1$ yum install m2crypto python-setuptools 安装pip 1yum -y install python-pip 或者（没试过）1$ easy_install pip 安装ss 1$ pip shadowsocks 配置服务器参数 1$ vi /etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, //服务器的IP地址 &quot;server_port&quot;:7711, //服务器的端口 &quot;local_address&quot;: &quot;127.0.0.1&quot;, //本机IP地址 &quot;local_port&quot;:1080, //本机端口 &quot;password&quot;:&quot;mypassword&quot;, //自己设定的密码 &quot;timeout&quot;:300, //超出时间 &quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方法，推荐使用&quot;aes-256-cfb&quot; &quot;fast_open&quot;: false //true 或 false&#125;&#125; 若是多用户模式，将server_port和password合并为port_password： 1234&quot;port_password&quot;: &#123; &quot;443&quot;: &quot; mypassword 1”, //对应端口设定不同的密码 &quot;8888&quot;: &quot; mypassword 2” &#125;, 安装gevent Gevent可以提高ss性能，由于gevent依赖于libevent和greenlet 123$ yum install -y libevent$ pip install greenlet$ pip install gevent 配置防火墙 为了提高系统的安全性，需要安装防火墙 1$ yum install firewalld 启动防火墙 1$ systemctl start firewalld 开启相应端口 12$ firewall-cmd --permanent --zone=public --add-port=443/tcp$ firewall-cmd –reload 查看修改ss服务器的端口密码 查看当前ss服务器所开放的端口 1ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件，配置文件中自然有密码 1ps aux | grep ssserver 用cat查看下配置文件即可看见密码了，vim修改 1vim /etc/shadowsocks.json ss启动停止方法 启动，停止，重启，状态：1234567service shadowsocks startservice shadowsocks stopservice shadowsocks restartservice shadowsocks status 参考：https://github.com/easonhuang123/blog/issues/1https://blog.whsir.com/post-1045.html]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>ShadowSocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳Python脚本]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3python%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[微信跳一跳Python脚本adb+python，用的话先装adb， 感觉80%能跳到中心吧。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123# -*- coding: utf-8 -*-import timefrom PIL import Imageimport osimport mathdef isPixFuzzyDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 10 and abs(g - pix[1]) &lt; 10 and abs(b - pix[2]) &lt; 10: return False else: return Truedef isPixAccurateDiff(r,g,b,pix): if abs(r - pix[0]) &lt; 1 and abs(g - pix[1]) &lt; 1 and abs(b - pix[2]) &lt; 1: return False else: return Truedef isWhiteCenter(pix): if pix[0] == 245 and pix[1] == 245 and pix[2] ==245: return True else: return False def getDistance(dep,des): if des[0] &gt; dep[0]: x1,x2 = des[0],dep[0] else: x2,x1 = des[0],dep[0] x = (x1 - x2) y = (dep[1] - des[1])/2 dis = (x**2+y**2)**0.5 return disdef getTopPixel(pix,height,width,depPix): topPixel = [0,0] if depPix[0] &lt; width/2: startpoint = depPix[0] + 40 endpoint = width - 2 else: startpoint = 40 endpoint = depPix[0] - 40 deltaX = x0 = 0 flag = False for y in range(int(0.18 * height),int(0.66 * height)): for x in range(startpoint,endpoint): if x == startpoint: r, g, b = pix[x, y][0:3] elif isPixFuzzyDiff(r,g,b,pix[x,y]): r, g, b = pix[x, y][0:3] flag = not flag if not flag: break x0 = x elif flag : deltaX += 1 else: continue break print deltaX topPixel = [x0 + math.floor(deltaX)/2,y] return topPixel# button == buttom 懒得改def getButtonPixel(topPixel,pix): buttonPixel = [topPixel[0],0] r, g, b = pix[topPixel[0],topPixel[1]][0:3] for y in range(topPixel[1],topPixel[1] + 250): if not isPixAccurateDiff(r,g,b,pix[topPixel[0],y]): buttonPixel[1] = y return buttonPixeldef getdepPix(pix,height,width): depPix = [0,0] for y in range(1388,200,-1): for x in range(2,width-2): if isPixAccurateDiff(54,60,102,pix[x,y]): continue else: depPix = [x,y] break else: continue break return depPixdef main(): for i in range(20): filename = str(int(time.time())) + '.png' time.sleep(2) print "filename: " + filename time.sleep(2) os.system('adb shell /system/bin/screencap -p /sdcard/jump/' + filename) print "screencap" time.sleep(2) os.system('adb pull /sdcard/jump/' + filename + ' d:/MyCode/Python/jump/' + filename) print "pull"## filename = '1515321961' + '.png' im = Image.open(filename) pix = im.load() width = im.size[0] height = im.size[1] depPix = getdepPix(pix,height,width) topPixel = getTopPixel(pix,height,width,depPix) buttonPixel = getButtonPixel(topPixel,pix) desPix = [topPixel[0],(buttonPixel[1] - topPixel[1])/2 + topPixel[1]] print topPixel print buttonPixel print desPix print depPix dis = getDistance(depPix,desPix) print "distance: " + str(dis) swipeTime = 722/475.1 * dis print "swipeTime:" + str(swipeTime) os.system("adb shell input swipe 250 250 300 300 " + str(int(swipeTime))) if __name__ == '__main__': main()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda序列化问题]]></title>
    <url>%2F2017%2F12%2F12%2FLambda%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Lambda序列化问题这几天用spark遇到一个问题，到现在仍没有解决，不过查到了一些思路，可能与序列化有关。 先上代码1234567891011//不用Lambda，没有问题lines.mapToPair(new PairFunction&lt;String, Integer, Integer&gt;() &#123; private static final long serialVersionUID = 1323L; @Override public Tuple2&lt;Integer, Integer&gt; call(String word) throws Exception &#123; return new Tuple2&lt;Integer, Integer&gt;(1, 1); &#125; &#125;).take(200).forEach(v -&gt; System.out.println(v));//用lambda，报错lines.mapToPair(v -&gt; new Tuple2&lt;Integer, Integer&gt;(1, 1)).take(200).forEach(v -&gt; System.out.println(v)); 错误信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495017/12/12 16:00:53 WARN TaskSetManager: Lost task 0.0 in stage 1.0 (TID 1, 10.103.244.216): java.io.IOException: unexpected exception type at java.io.ObjectStreamClass.throwMiscException(ObjectStreamClass.java:1582) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1154) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2022) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2231) at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2155) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2013) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422) at org.apache.spark.serializer.JavaDeserializationStream.readObject(JavaSerializer.scala:76) at org.apache.spark.serializer.JavaSerializerInstance.deserialize(JavaSerializer.scala:115) at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:61) at org.apache.spark.scheduler.Task.run(Task.scala:89) at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:213) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)Caused by: java.lang.NoSuchMethodException: TestSUANZI.test.$deserializeLambda$(java.lang.invoke.SerializedLambda) at java.lang.Class.getDeclaredMethod(Class.java:2130) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:224) at java.lang.invoke.SerializedLambda$1.run(SerializedLambda.java:221) at java.security.AccessController.doPrivileged(Native Method) at java.lang.invoke.SerializedLambda.readResolve(SerializedLambda.java:221) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at java.io.ObjectStreamClass.invokeReadResolve(ObjectStreamClass.java:1148) ... 27 more17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.1 in stage 1.0 (TID 2, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.1 in stage 1.0 (TID 2) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 1]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.2 in stage 1.0 (TID 3, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.2 in stage 1.0 (TID 3) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 2]17/12/12 16:00:53 INFO TaskSetManager: Starting task 0.3 in stage 1.0 (TID 4, 10.103.244.216, partition 0,ANY, 2193 bytes)17/12/12 16:00:53 INFO TaskSetManager: Lost task 0.3 in stage 1.0 (TID 4) on executor 10.103.244.216: java.io.IOException (unexpected exception type) [duplicate 3]17/12/12 16:00:53 ERROR TaskSetManager: Task 0 in stage 1.0 failed 4 times; aborting job 目前的解决方法是实现Serializable这个接口。 有时间读一下https://www.zhihu.com/question/51491241/answer/126232275]]></content>
      <categories>
        <category>Lambda表达式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrapyDemo]]></title>
    <url>%2F2017%2F11%2F30%2FScrapyDemo%2F</url>
    <content type="text"><![CDATA[建立工程 scrapy startproject scrapydemo 目录分析 scrapy.cfg: 项目的配置文件 scrapytest/: 该项目的python模块。之后您将在此加入代码。 scrapytest/items.py: 项目中的item文件. scrapytest/pipelines.py: 项目中的pipelines文件. scrapytest/settings.py: 项目的设置文件. scrapytest/spiders/: 放置spider代码的目录. Tips1. spider name/spiders/目录下创建一个文件-name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 2.多级抓取scrapy 在不同的抓取级别的Request之间传递参数的办法，下面的范例中，parse()通过meat传递给了parse_more()参数item，这样就可以再parse_more()抓取完成所有的数据后一次返123456789def parse(self, response): …… item['url'] = url.extract()[0] for item in items: yield Request(url = item['url'],meta = &#123;'item':item&#125;, callback = self.parse_more,dont_filter = True)def parse_more(self,response): item = response.meta['item'] …… yield item 总结需要修改demo的地方demo地址:https://github.com/CherryKeinz/ScrapyDemo 1. items.py修改类demoItem()里需要的字段 2. /spiders/MySpider.pyimport 要改为items.py中定义的类名from SpiderDemo.items import demoItem allowed_domains = [“http://10.3.210.84:4237/home/“]这个是 spider要求设置的一个变量,表示允许爬虫爬的网站 start_urls.append(url) url改为要爬的网址 如需保存为JSON，修改custom_settings 3.pipelines.py如需要，修改类JsonWithEncodingPipeline 常见错误 scrapy 报错 no module named win32api 的解决方案原因是缺少win32,到 http://sourceforge.net/projects/pywin32/files/找到对应的版本进行下载，直接安装即可]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo nexT的一些玩法（转载+总结）]]></title>
    <url>%2F2017%2F11%2F22%2FHexo-nexT%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基础篇1. 常用命令12345678hexo new &quot;HelloWorld&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo d #部署 #可与hexo g合并为 hexo d -g 2. 文章中插入图片对于hexo，有两种方式：使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。使用微博图床，地址 http://weibotuchuang.sinaapp.com/ ，将图片拖入区域中，会生成图片的URL，这就是链接地址。 3. 添加分页、标签页面 新建命令： hexo new page tags # tags可替换成其他 输入命令后，在/source下会新生成一个新的文件夹tags，在该文件夹下会有一个index.md文件。在上步新生成的myBlog/source/tags/index.md中添加type: “tags”，index.md文件内容如下：设置具体文章的tags当要为某一篇文章添加标签，只需在/source/_post目录下的具体文章的tags中添加标签即可，如： tags: [hexo,next] 4. 引入第三方服务参考 : http://theme-next.iissnan.com/third-party-services.html#swfitype 加入分享功能在主题配置文件中，jiathis: true 加入评论功能待续 加入站点内容搜索功能1) 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： $ npm install hexo-generator-searchdb –save 2) 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 3) 编辑 主题配置文件，启用本地搜索功能： 1enable: true 数据统计 待续 个性化 (参考)1. 修改文章内链接文本样式（待考证）修改文件 themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 2. 修改文章底部的那个带#号的标签修改模板/themes/next/layout/_macro/post.swig，搜索 rel=”tag”&gt;#，将 # 换成/&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;/ 3. 在每篇文章末尾统一添加“本文结束”标记在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 3. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：class12 &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;&lt;/span&gt; 然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 4. 添加顶部加载条打开/themes/next/layout/_partials/head.swig文件，修改为 :123456&lt;meta charset=&quot;UTF-8&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;/&gt;&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;&#123;&#123; theme.android_chrome_color &#125;&#125;&quot;&gt; 参考资料：http://www.jianshu.com/p/c23902f93558http://blog.csdn.net/qq_33699981/article/details/72716951http://playingfingers.com/2016/03/26/build-a-blog/https://segmentfault.com/a/1190000003946969]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
